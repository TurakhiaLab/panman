// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mutation_annotation_test_proto3_optional_new.proto

#include "mutation_annotation_test_proto3_optional_new.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace MATNew {
PROTOBUF_CONSTEXPR nucMut::nucMut(
    ::_pbi::ConstantInitialized)
  : nucposition_(0)
  , nucgapposition_(0)
  , nucgapexist_(false)
  , mutinfo_(0u){}
struct nucMutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR nucMutDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~nucMutDefaultTypeInternal() {}
  union {
    nucMut _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 nucMutDefaultTypeInternal _nucMut_default_instance_;
PROTOBUF_CONSTEXPR mutation::mutation(
    ::_pbi::ConstantInitialized)
  : nucmutation_()
  , blockid_(int64_t{0})
  , blockgapexist_(false)
  , blockmutexist_(false)
  , blockmutinfo_(false)
  , blockinversion_(false){}
struct mutationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mutationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~mutationDefaultTypeInternal() {}
  union {
    mutation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mutationDefaultTypeInternal _mutation_default_instance_;
PROTOBUF_CONSTEXPR node::node(
    ::_pbi::ConstantInitialized)
  : mutations_()
  , annotations_(){}
struct nodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR nodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~nodeDefaultTypeInternal() {}
  union {
    node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 nodeDefaultTypeInternal _node_default_instance_;
PROTOBUF_CONSTEXPR consensusSeqToBlockIds::consensusSeqToBlockIds(
    ::_pbi::ConstantInitialized)
  : blockid_()
  , _blockid_cached_byte_size_(0)
  , consensusseq_()
  , _consensusseq_cached_byte_size_(0)
  , blockgapexist_()
  , chromosomename_(){}
struct consensusSeqToBlockIdsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR consensusSeqToBlockIdsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~consensusSeqToBlockIdsDefaultTypeInternal() {}
  union {
    consensusSeqToBlockIds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 consensusSeqToBlockIdsDefaultTypeInternal _consensusSeqToBlockIds_default_instance_;
PROTOBUF_CONSTEXPR gapList::gapList(
    ::_pbi::ConstantInitialized)
  : nucgaplength_()
  , _nucgaplength_cached_byte_size_(0)
  , nucposition_()
  , _nucposition_cached_byte_size_(0)
  , blockid_(int64_t{0})
  , blockgapexist_(false){}
struct gapListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR gapListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~gapListDefaultTypeInternal() {}
  union {
    gapList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 gapListDefaultTypeInternal _gapList_default_instance_;
PROTOBUF_CONSTEXPR blockGapList::blockGapList(
    ::_pbi::ConstantInitialized)
  : blockposition_()
  , _blockposition_cached_byte_size_(0)
  , blockgaplength_()
  , _blockgaplength_cached_byte_size_(0){}
struct blockGapListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR blockGapListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~blockGapListDefaultTypeInternal() {}
  union {
    blockGapList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 blockGapListDefaultTypeInternal _blockGapList_default_instance_;
PROTOBUF_CONSTEXPR circularOffset::circularOffset(
    ::_pbi::ConstantInitialized)
  : sequenceid_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , offset_(0){}
struct circularOffsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR circularOffsetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~circularOffsetDefaultTypeInternal() {}
  union {
    circularOffset _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 circularOffsetDefaultTypeInternal _circularOffset_default_instance_;
PROTOBUF_CONSTEXPR tree::tree(
    ::_pbi::ConstantInitialized)
  : nodes_()
  , consensusseqmap_()
  , gaps_()
  , circularsequences_()
  , newick_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , blockgaps_(nullptr){}
struct treeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR treeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~treeDefaultTypeInternal() {}
  union {
    tree _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 treeDefaultTypeInternal _tree_default_instance_;
PROTOBUF_CONSTEXPR complexMutation::complexMutation(
    ::_pbi::ConstantInitialized)
  : sequenceid1_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sequenceid2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sequenceid3_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , treeindex1_(0)
  , treeindex2_(0)
  , blockidstart1_(int64_t{0})
  , treeindex3_(0)
  , mutationtype_(false)
  , blockgapexiststart1_(false)
  , nucgapexiststart1_(false)
  , blockgapexistend1_(false)
  , nucpositionstart1_(0)
  , nucgappositionstart1_(0)
  , blockidend1_(int64_t{0})
  , nucpositionend1_(0)
  , nucgappositionend1_(0)
  , blockidstart2_(int64_t{0})
  , nucpositionstart2_(0)
  , nucgapexistend1_(false)
  , blockgapexiststart2_(false)
  , nucgapexiststart2_(false)
  , blockgapexistend2_(false)
  , blockidend2_(int64_t{0})
  , nucgappositionstart2_(0)
  , nucpositionend2_(0)
  , nucgappositionend2_(0)
  , nucgapexistend2_(false){}
struct complexMutationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR complexMutationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~complexMutationDefaultTypeInternal() {}
  union {
    complexMutation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 complexMutationDefaultTypeInternal _complexMutation_default_instance_;
PROTOBUF_CONSTEXPR treeGroup::treeGroup(
    ::_pbi::ConstantInitialized)
  : trees_()
  , complexmutations_(){}
struct treeGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR treeGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~treeGroupDefaultTypeInternal() {}
  union {
    treeGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 treeGroupDefaultTypeInternal _treeGroup_default_instance_;
}  // namespace MATNew
static ::_pb::Metadata file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[10];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto = nullptr;

const uint32_t TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::nucMut, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::nucMut, nucposition_),
  PROTOBUF_FIELD_OFFSET(::MATNew::nucMut, nucgapposition_),
  PROTOBUF_FIELD_OFFSET(::MATNew::nucMut, nucgapexist_),
  PROTOBUF_FIELD_OFFSET(::MATNew::nucMut, mutinfo_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, blockid_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, blockgapexist_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, blockmutexist_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, blockmutinfo_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, blockinversion_),
  PROTOBUF_FIELD_OFFSET(::MATNew::mutation, nucmutation_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::node, mutations_),
  PROTOBUF_FIELD_OFFSET(::MATNew::node, annotations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::consensusSeqToBlockIds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::consensusSeqToBlockIds, blockid_),
  PROTOBUF_FIELD_OFFSET(::MATNew::consensusSeqToBlockIds, consensusseq_),
  PROTOBUF_FIELD_OFFSET(::MATNew::consensusSeqToBlockIds, blockgapexist_),
  PROTOBUF_FIELD_OFFSET(::MATNew::consensusSeqToBlockIds, chromosomename_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::gapList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::gapList, blockid_),
  PROTOBUF_FIELD_OFFSET(::MATNew::gapList, blockgapexist_),
  PROTOBUF_FIELD_OFFSET(::MATNew::gapList, nucgaplength_),
  PROTOBUF_FIELD_OFFSET(::MATNew::gapList, nucposition_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::blockGapList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::blockGapList, blockposition_),
  PROTOBUF_FIELD_OFFSET(::MATNew::blockGapList, blockgaplength_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::circularOffset, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::circularOffset, sequenceid_),
  PROTOBUF_FIELD_OFFSET(::MATNew::circularOffset, offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, newick_),
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, nodes_),
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, consensusseqmap_),
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, gaps_),
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, blockgaps_),
  PROTOBUF_FIELD_OFFSET(::MATNew::tree, circularsequences_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, mutationtype_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, treeindex1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, treeindex2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, treeindex3_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, sequenceid1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, sequenceid2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockidstart1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockgapexiststart1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucpositionstart1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgappositionstart1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgapexiststart1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockidend1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockgapexistend1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucpositionend1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgappositionend1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgapexistend1_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockidstart2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockgapexiststart2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucpositionstart2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgappositionstart2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgapexiststart2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockidend2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, blockgapexistend2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucpositionend2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgappositionend2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, nucgapexistend2_),
  PROTOBUF_FIELD_OFFSET(::MATNew::complexMutation, sequenceid3_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MATNew::treeGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MATNew::treeGroup, trees_),
  PROTOBUF_FIELD_OFFSET(::MATNew::treeGroup, complexmutations_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::MATNew::nucMut)},
  { 10, 22, -1, sizeof(::MATNew::mutation)},
  { 28, -1, -1, sizeof(::MATNew::node)},
  { 36, -1, -1, sizeof(::MATNew::consensusSeqToBlockIds)},
  { 46, -1, -1, sizeof(::MATNew::gapList)},
  { 56, -1, -1, sizeof(::MATNew::blockGapList)},
  { 64, -1, -1, sizeof(::MATNew::circularOffset)},
  { 72, -1, -1, sizeof(::MATNew::tree)},
  { 84, -1, -1, sizeof(::MATNew::complexMutation)},
  { 117, -1, -1, sizeof(::MATNew::treeGroup)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::MATNew::_nucMut_default_instance_._instance,
  &::MATNew::_mutation_default_instance_._instance,
  &::MATNew::_node_default_instance_._instance,
  &::MATNew::_consensusSeqToBlockIds_default_instance_._instance,
  &::MATNew::_gapList_default_instance_._instance,
  &::MATNew::_blockGapList_default_instance_._instance,
  &::MATNew::_circularOffset_default_instance_._instance,
  &::MATNew::_tree_default_instance_._instance,
  &::MATNew::_complexMutation_default_instance_._instance,
  &::MATNew::_treeGroup_default_instance_._instance,
};

const char descriptor_table_protodef_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n2mutation_annotation_test_proto3_option"
  "al_new.proto\022\006MATNew\"[\n\006nucMut\022\023\n\013nucPos"
  "ition\030\001 \001(\005\022\026\n\016nucGapPosition\030\002 \001(\005\022\023\n\013n"
  "ucGapExist\030\003 \001(\010\022\017\n\007mutInfo\030\004 \001(\r\"\264\001\n\010mu"
  "tation\022\017\n\007blockId\030\001 \001(\003\022\025\n\rblockGapExist"
  "\030\002 \001(\010\022\025\n\rblockMutExist\030\003 \001(\010\022\024\n\014blockMu"
  "tInfo\030\004 \001(\010\022\033\n\016blockInversion\030\005 \001(\010H\000\210\001\001"
  "\022#\n\013nucMutation\030\006 \003(\0132\016.MATNew.nucMutB\021\n"
  "\017_blockInversion\"@\n\004node\022#\n\tmutations\030\001 "
  "\003(\0132\020.MATNew.mutation\022\023\n\013annotations\030\002 \003"
  "(\t\"n\n\026consensusSeqToBlockIds\022\017\n\007blockId\030"
  "\001 \003(\003\022\024\n\014consensusSeq\030\002 \003(\r\022\025\n\rblockGapE"
  "xist\030\003 \003(\010\022\026\n\016chromosomeName\030\004 \003(\t\"\\\n\007ga"
  "pList\022\017\n\007blockId\030\001 \001(\003\022\025\n\rblockGapExist\030"
  "\002 \001(\010\022\024\n\014nucGapLength\030\003 \003(\005\022\023\n\013nucPositi"
  "on\030\004 \003(\005\"=\n\014blockGapList\022\025\n\rblockPositio"
  "n\030\001 \003(\005\022\026\n\016blockGapLength\030\002 \003(\005\"4\n\016circu"
  "larOffset\022\022\n\nsequenceId\030\001 \001(\t\022\016\n\006offset\030"
  "\002 \001(\005\"\347\001\n\004tree\022\016\n\006newick\030\001 \001(\t\022\033\n\005nodes\030"
  "\002 \003(\0132\014.MATNew.node\0227\n\017consensusSeqMap\030\004"
  " \003(\0132\036.MATNew.consensusSeqToBlockIds\022\035\n\004"
  "gaps\030\005 \003(\0132\017.MATNew.gapList\022\'\n\tblockGaps"
  "\030\006 \001(\0132\024.MATNew.blockGapList\0221\n\021circular"
  "Sequences\030\007 \003(\0132\026.MATNew.circularOffset\""
  "\256\005\n\017complexMutation\022\024\n\014mutationType\030\001 \001("
  "\010\022\022\n\ntreeIndex1\030\002 \001(\005\022\022\n\ntreeIndex2\030\003 \001("
  "\005\022\022\n\ntreeIndex3\030\004 \001(\005\022\023\n\013sequenceId1\030\005 \001"
  "(\t\022\023\n\013sequenceId2\030\006 \001(\t\022\025\n\rblockIdStart1"
  "\030\007 \001(\003\022\033\n\023blockGapExistStart1\030\010 \001(\010\022\031\n\021n"
  "ucPositionStart1\030\t \001(\005\022\034\n\024nucGapPosition"
  "Start1\030\n \001(\005\022\031\n\021nucGapExistStart1\030\013 \001(\010\022"
  "\023\n\013blockIdEnd1\030\014 \001(\003\022\031\n\021blockGapExistEnd"
  "1\030\r \001(\010\022\027\n\017nucPositionEnd1\030\016 \001(\005\022\032\n\022nucG"
  "apPositionEnd1\030\017 \001(\005\022\027\n\017nucGapExistEnd1\030"
  "\020 \001(\010\022\025\n\rblockIdStart2\030\021 \001(\003\022\033\n\023blockGap"
  "ExistStart2\030\022 \001(\010\022\031\n\021nucPositionStart2\030\023"
  " \001(\005\022\034\n\024nucGapPositionStart2\030\024 \001(\005\022\031\n\021nu"
  "cGapExistStart2\030\025 \001(\010\022\023\n\013blockIdEnd2\030\026 \001"
  "(\003\022\031\n\021blockGapExistEnd2\030\027 \001(\010\022\027\n\017nucPosi"
  "tionEnd2\030\030 \001(\005\022\032\n\022nucGapPositionEnd2\030\031 \001"
  "(\005\022\027\n\017nucGapExistEnd2\030\032 \001(\010\022\023\n\013sequenceI"
  "d3\030\033 \001(\t\"[\n\ttreeGroup\022\033\n\005trees\030\001 \003(\0132\014.M"
  "ATNew.tree\0221\n\020complexMutations\030\002 \003(\0132\027.M"
  "ATNew.complexMutationb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto = {
    false, false, 1749, descriptor_table_protodef_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto,
    "mutation_annotation_test_proto3_optional_new.proto",
    &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto::offsets,
    file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto, file_level_enum_descriptors_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto,
    file_level_service_descriptors_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter() {
  return &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto(&descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto);
namespace MATNew {

// ===================================================================

class nucMut::_Internal {
 public:
};

nucMut::nucMut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.nucMut)
}
nucMut::nucMut(const nucMut& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&nucposition_, &from.nucposition_,
    static_cast<size_t>(reinterpret_cast<char*>(&mutinfo_) -
    reinterpret_cast<char*>(&nucposition_)) + sizeof(mutinfo_));
  // @@protoc_insertion_point(copy_constructor:MATNew.nucMut)
}

inline void nucMut::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nucposition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mutinfo_) -
    reinterpret_cast<char*>(&nucposition_)) + sizeof(mutinfo_));
}

nucMut::~nucMut() {
  // @@protoc_insertion_point(destructor:MATNew.nucMut)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void nucMut::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void nucMut::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void nucMut::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.nucMut)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&nucposition_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mutinfo_) -
      reinterpret_cast<char*>(&nucposition_)) + sizeof(mutinfo_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* nucMut::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 nucPosition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          nucposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucGapPosition = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          nucgapposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nucGapExist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          nucgapexist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 mutInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          mutinfo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* nucMut::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.nucMut)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 nucPosition = 1;
  if (this->_internal_nucposition() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_nucposition(), target);
  }

  // int32 nucGapPosition = 2;
  if (this->_internal_nucgapposition() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nucgapposition(), target);
  }

  // bool nucGapExist = 3;
  if (this->_internal_nucgapexist() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_nucgapexist(), target);
  }

  // uint32 mutInfo = 4;
  if (this->_internal_mutinfo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mutinfo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.nucMut)
  return target;
}

size_t nucMut::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.nucMut)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 nucPosition = 1;
  if (this->_internal_nucposition() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucposition());
  }

  // int32 nucGapPosition = 2;
  if (this->_internal_nucgapposition() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucgapposition());
  }

  // bool nucGapExist = 3;
  if (this->_internal_nucgapexist() != 0) {
    total_size += 1 + 1;
  }

  // uint32 mutInfo = 4;
  if (this->_internal_mutinfo() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mutinfo());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData nucMut::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    nucMut::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*nucMut::GetClassData() const { return &_class_data_; }

void nucMut::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<nucMut *>(to)->MergeFrom(
      static_cast<const nucMut &>(from));
}


void nucMut::MergeFrom(const nucMut& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.nucMut)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nucposition() != 0) {
    _internal_set_nucposition(from._internal_nucposition());
  }
  if (from._internal_nucgapposition() != 0) {
    _internal_set_nucgapposition(from._internal_nucgapposition());
  }
  if (from._internal_nucgapexist() != 0) {
    _internal_set_nucgapexist(from._internal_nucgapexist());
  }
  if (from._internal_mutinfo() != 0) {
    _internal_set_mutinfo(from._internal_mutinfo());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void nucMut::CopyFrom(const nucMut& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.nucMut)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool nucMut::IsInitialized() const {
  return true;
}

void nucMut::InternalSwap(nucMut* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(nucMut, mutinfo_)
      + sizeof(nucMut::mutinfo_)
      - PROTOBUF_FIELD_OFFSET(nucMut, nucposition_)>(
          reinterpret_cast<char*>(&nucposition_),
          reinterpret_cast<char*>(&other->nucposition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata nucMut::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[0]);
}

// ===================================================================

class mutation::_Internal {
 public:
  using HasBits = decltype(std::declval<mutation>()._has_bits_);
  static void set_has_blockinversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

mutation::mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nucmutation_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.mutation)
}
mutation::mutation(const mutation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nucmutation_(from.nucmutation_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&blockid_, &from.blockid_,
    static_cast<size_t>(reinterpret_cast<char*>(&blockinversion_) -
    reinterpret_cast<char*>(&blockid_)) + sizeof(blockinversion_));
  // @@protoc_insertion_point(copy_constructor:MATNew.mutation)
}

inline void mutation::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&blockid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blockinversion_) -
    reinterpret_cast<char*>(&blockid_)) + sizeof(blockinversion_));
}

mutation::~mutation() {
  // @@protoc_insertion_point(destructor:MATNew.mutation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mutation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void mutation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void mutation::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.mutation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nucmutation_.Clear();
  ::memset(&blockid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blockmutinfo_) -
      reinterpret_cast<char*>(&blockid_)) + sizeof(blockmutinfo_));
  blockinversion_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* mutation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 blockId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          blockid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          blockgapexist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockMutExist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          blockmutexist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockMutInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          blockmutinfo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool blockInversion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_blockinversion(&has_bits);
          blockinversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.nucMut nucMutation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nucmutation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* mutation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.mutation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 blockId = 1;
  if (this->_internal_blockid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_blockid(), target);
  }

  // bool blockGapExist = 2;
  if (this->_internal_blockgapexist() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_blockgapexist(), target);
  }

  // bool blockMutExist = 3;
  if (this->_internal_blockmutexist() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_blockmutexist(), target);
  }

  // bool blockMutInfo = 4;
  if (this->_internal_blockmutinfo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_blockmutinfo(), target);
  }

  // optional bool blockInversion = 5;
  if (_internal_has_blockinversion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_blockinversion(), target);
  }

  // repeated .MATNew.nucMut nucMutation = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nucmutation_size()); i < n; i++) {
    const auto& repfield = this->_internal_nucmutation(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.mutation)
  return target;
}

size_t mutation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.mutation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MATNew.nucMut nucMutation = 6;
  total_size += 1UL * this->_internal_nucmutation_size();
  for (const auto& msg : this->nucmutation_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 blockId = 1;
  if (this->_internal_blockid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_blockid());
  }

  // bool blockGapExist = 2;
  if (this->_internal_blockgapexist() != 0) {
    total_size += 1 + 1;
  }

  // bool blockMutExist = 3;
  if (this->_internal_blockmutexist() != 0) {
    total_size += 1 + 1;
  }

  // bool blockMutInfo = 4;
  if (this->_internal_blockmutinfo() != 0) {
    total_size += 1 + 1;
  }

  // optional bool blockInversion = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData mutation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    mutation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*mutation::GetClassData() const { return &_class_data_; }

void mutation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<mutation *>(to)->MergeFrom(
      static_cast<const mutation &>(from));
}


void mutation::MergeFrom(const mutation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.mutation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nucmutation_.MergeFrom(from.nucmutation_);
  if (from._internal_blockid() != 0) {
    _internal_set_blockid(from._internal_blockid());
  }
  if (from._internal_blockgapexist() != 0) {
    _internal_set_blockgapexist(from._internal_blockgapexist());
  }
  if (from._internal_blockmutexist() != 0) {
    _internal_set_blockmutexist(from._internal_blockmutexist());
  }
  if (from._internal_blockmutinfo() != 0) {
    _internal_set_blockmutinfo(from._internal_blockmutinfo());
  }
  if (from._internal_has_blockinversion()) {
    _internal_set_blockinversion(from._internal_blockinversion());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void mutation::CopyFrom(const mutation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.mutation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mutation::IsInitialized() const {
  return true;
}

void mutation::InternalSwap(mutation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nucmutation_.InternalSwap(&other->nucmutation_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mutation, blockinversion_)
      + sizeof(mutation::blockinversion_)
      - PROTOBUF_FIELD_OFFSET(mutation, blockid_)>(
          reinterpret_cast<char*>(&blockid_),
          reinterpret_cast<char*>(&other->blockid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata mutation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[1]);
}

// ===================================================================

class node::_Internal {
 public:
};

node::node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mutations_(arena),
  annotations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.node)
}
node::node(const node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      mutations_(from.mutations_),
      annotations_(from.annotations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:MATNew.node)
}

inline void node::SharedCtor() {
}

node::~node() {
  // @@protoc_insertion_point(destructor:MATNew.node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void node::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mutations_.Clear();
  annotations_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .MATNew.mutation mutations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mutations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string annotations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_annotations();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "MATNew.node.annotations"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .MATNew.mutation mutations = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mutations_size()); i < n; i++) {
    const auto& repfield = this->_internal_mutations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string annotations = 2;
  for (int i = 0, n = this->_internal_annotations_size(); i < n; i++) {
    const auto& s = this->_internal_annotations(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.node.annotations");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.node)
  return target;
}

size_t node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MATNew.mutation mutations = 1;
  total_size += 1UL * this->_internal_mutations_size();
  for (const auto& msg : this->mutations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string annotations = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(annotations_.size());
  for (int i = 0, n = annotations_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      annotations_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*node::GetClassData() const { return &_class_data_; }

void node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<node *>(to)->MergeFrom(
      static_cast<const node &>(from));
}


void node::MergeFrom(const node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.node)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mutations_.MergeFrom(from.mutations_);
  annotations_.MergeFrom(from.annotations_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void node::CopyFrom(const node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool node::IsInitialized() const {
  return true;
}

void node::InternalSwap(node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  mutations_.InternalSwap(&other->mutations_);
  annotations_.InternalSwap(&other->annotations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[2]);
}

// ===================================================================

class consensusSeqToBlockIds::_Internal {
 public:
};

consensusSeqToBlockIds::consensusSeqToBlockIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  blockid_(arena),
  consensusseq_(arena),
  blockgapexist_(arena),
  chromosomename_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.consensusSeqToBlockIds)
}
consensusSeqToBlockIds::consensusSeqToBlockIds(const consensusSeqToBlockIds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      blockid_(from.blockid_),
      consensusseq_(from.consensusseq_),
      blockgapexist_(from.blockgapexist_),
      chromosomename_(from.chromosomename_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:MATNew.consensusSeqToBlockIds)
}

inline void consensusSeqToBlockIds::SharedCtor() {
}

consensusSeqToBlockIds::~consensusSeqToBlockIds() {
  // @@protoc_insertion_point(destructor:MATNew.consensusSeqToBlockIds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void consensusSeqToBlockIds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void consensusSeqToBlockIds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void consensusSeqToBlockIds::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.consensusSeqToBlockIds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  blockid_.Clear();
  consensusseq_.Clear();
  blockgapexist_.Clear();
  chromosomename_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* consensusSeqToBlockIds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 blockId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_blockid(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_blockid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 consensusSeq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_consensusseq(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_consensusseq(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool blockGapExist = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_blockgapexist(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_blockgapexist(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string chromosomeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_chromosomename();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "MATNew.consensusSeqToBlockIds.chromosomeName"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* consensusSeqToBlockIds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.consensusSeqToBlockIds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 blockId = 1;
  {
    int byte_size = _blockid_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_blockid(), byte_size, target);
    }
  }

  // repeated uint32 consensusSeq = 2;
  {
    int byte_size = _consensusseq_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_consensusseq(), byte_size, target);
    }
  }

  // repeated bool blockGapExist = 3;
  if (this->_internal_blockgapexist_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_blockgapexist(), target);
  }

  // repeated string chromosomeName = 4;
  for (int i = 0, n = this->_internal_chromosomename_size(); i < n; i++) {
    const auto& s = this->_internal_chromosomename(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.consensusSeqToBlockIds.chromosomeName");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.consensusSeqToBlockIds)
  return target;
}

size_t consensusSeqToBlockIds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.consensusSeqToBlockIds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 blockId = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->blockid_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _blockid_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 consensusSeq = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->consensusseq_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _consensusseq_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool blockGapExist = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_blockgapexist_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated string chromosomeName = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(chromosomename_.size());
  for (int i = 0, n = chromosomename_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      chromosomename_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData consensusSeqToBlockIds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    consensusSeqToBlockIds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*consensusSeqToBlockIds::GetClassData() const { return &_class_data_; }

void consensusSeqToBlockIds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<consensusSeqToBlockIds *>(to)->MergeFrom(
      static_cast<const consensusSeqToBlockIds &>(from));
}


void consensusSeqToBlockIds::MergeFrom(const consensusSeqToBlockIds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.consensusSeqToBlockIds)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  blockid_.MergeFrom(from.blockid_);
  consensusseq_.MergeFrom(from.consensusseq_);
  blockgapexist_.MergeFrom(from.blockgapexist_);
  chromosomename_.MergeFrom(from.chromosomename_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void consensusSeqToBlockIds::CopyFrom(const consensusSeqToBlockIds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.consensusSeqToBlockIds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool consensusSeqToBlockIds::IsInitialized() const {
  return true;
}

void consensusSeqToBlockIds::InternalSwap(consensusSeqToBlockIds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  blockid_.InternalSwap(&other->blockid_);
  consensusseq_.InternalSwap(&other->consensusseq_);
  blockgapexist_.InternalSwap(&other->blockgapexist_);
  chromosomename_.InternalSwap(&other->chromosomename_);
}

::PROTOBUF_NAMESPACE_ID::Metadata consensusSeqToBlockIds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[3]);
}

// ===================================================================

class gapList::_Internal {
 public:
};

gapList::gapList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nucgaplength_(arena),
  nucposition_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.gapList)
}
gapList::gapList(const gapList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nucgaplength_(from.nucgaplength_),
      nucposition_(from.nucposition_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&blockid_, &from.blockid_,
    static_cast<size_t>(reinterpret_cast<char*>(&blockgapexist_) -
    reinterpret_cast<char*>(&blockid_)) + sizeof(blockgapexist_));
  // @@protoc_insertion_point(copy_constructor:MATNew.gapList)
}

inline void gapList::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&blockid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blockgapexist_) -
    reinterpret_cast<char*>(&blockid_)) + sizeof(blockgapexist_));
}

gapList::~gapList() {
  // @@protoc_insertion_point(destructor:MATNew.gapList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void gapList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void gapList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void gapList::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.gapList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nucgaplength_.Clear();
  nucposition_.Clear();
  ::memset(&blockid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blockgapexist_) -
      reinterpret_cast<char*>(&blockid_)) + sizeof(blockgapexist_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* gapList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 blockId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          blockid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          blockgapexist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 nucGapLength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_nucgaplength(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_nucgaplength(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 nucPosition = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_nucposition(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_nucposition(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* gapList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.gapList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 blockId = 1;
  if (this->_internal_blockid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_blockid(), target);
  }

  // bool blockGapExist = 2;
  if (this->_internal_blockgapexist() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_blockgapexist(), target);
  }

  // repeated int32 nucGapLength = 3;
  {
    int byte_size = _nucgaplength_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_nucgaplength(), byte_size, target);
    }
  }

  // repeated int32 nucPosition = 4;
  {
    int byte_size = _nucposition_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_nucposition(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.gapList)
  return target;
}

size_t gapList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.gapList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 nucGapLength = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->nucgaplength_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _nucgaplength_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 nucPosition = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->nucposition_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _nucposition_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 blockId = 1;
  if (this->_internal_blockid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_blockid());
  }

  // bool blockGapExist = 2;
  if (this->_internal_blockgapexist() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData gapList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    gapList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*gapList::GetClassData() const { return &_class_data_; }

void gapList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<gapList *>(to)->MergeFrom(
      static_cast<const gapList &>(from));
}


void gapList::MergeFrom(const gapList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.gapList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nucgaplength_.MergeFrom(from.nucgaplength_);
  nucposition_.MergeFrom(from.nucposition_);
  if (from._internal_blockid() != 0) {
    _internal_set_blockid(from._internal_blockid());
  }
  if (from._internal_blockgapexist() != 0) {
    _internal_set_blockgapexist(from._internal_blockgapexist());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void gapList::CopyFrom(const gapList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.gapList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gapList::IsInitialized() const {
  return true;
}

void gapList::InternalSwap(gapList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nucgaplength_.InternalSwap(&other->nucgaplength_);
  nucposition_.InternalSwap(&other->nucposition_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(gapList, blockgapexist_)
      + sizeof(gapList::blockgapexist_)
      - PROTOBUF_FIELD_OFFSET(gapList, blockid_)>(
          reinterpret_cast<char*>(&blockid_),
          reinterpret_cast<char*>(&other->blockid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata gapList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[4]);
}

// ===================================================================

class blockGapList::_Internal {
 public:
};

blockGapList::blockGapList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  blockposition_(arena),
  blockgaplength_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.blockGapList)
}
blockGapList::blockGapList(const blockGapList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      blockposition_(from.blockposition_),
      blockgaplength_(from.blockgaplength_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:MATNew.blockGapList)
}

inline void blockGapList::SharedCtor() {
}

blockGapList::~blockGapList() {
  // @@protoc_insertion_point(destructor:MATNew.blockGapList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void blockGapList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void blockGapList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void blockGapList::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.blockGapList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  blockposition_.Clear();
  blockgaplength_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* blockGapList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 blockPosition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_blockposition(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_blockposition(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 blockGapLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_blockgaplength(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_blockgaplength(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* blockGapList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.blockGapList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 blockPosition = 1;
  {
    int byte_size = _blockposition_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_blockposition(), byte_size, target);
    }
  }

  // repeated int32 blockGapLength = 2;
  {
    int byte_size = _blockgaplength_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_blockgaplength(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.blockGapList)
  return target;
}

size_t blockGapList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.blockGapList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 blockPosition = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->blockposition_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _blockposition_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 blockGapLength = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->blockgaplength_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _blockgaplength_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData blockGapList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    blockGapList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*blockGapList::GetClassData() const { return &_class_data_; }

void blockGapList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<blockGapList *>(to)->MergeFrom(
      static_cast<const blockGapList &>(from));
}


void blockGapList::MergeFrom(const blockGapList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.blockGapList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  blockposition_.MergeFrom(from.blockposition_);
  blockgaplength_.MergeFrom(from.blockgaplength_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void blockGapList::CopyFrom(const blockGapList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.blockGapList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool blockGapList::IsInitialized() const {
  return true;
}

void blockGapList::InternalSwap(blockGapList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  blockposition_.InternalSwap(&other->blockposition_);
  blockgaplength_.InternalSwap(&other->blockgaplength_);
}

::PROTOBUF_NAMESPACE_ID::Metadata blockGapList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[5]);
}

// ===================================================================

class circularOffset::_Internal {
 public:
};

circularOffset::circularOffset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.circularOffset)
}
circularOffset::circularOffset(const circularOffset& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sequenceid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequenceid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequenceid().empty()) {
    sequenceid_.Set(from._internal_sequenceid(), 
      GetArenaForAllocation());
  }
  offset_ = from.offset_;
  // @@protoc_insertion_point(copy_constructor:MATNew.circularOffset)
}

inline void circularOffset::SharedCtor() {
sequenceid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequenceid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
offset_ = 0;
}

circularOffset::~circularOffset() {
  // @@protoc_insertion_point(destructor:MATNew.circularOffset)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void circularOffset::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sequenceid_.Destroy();
}

void circularOffset::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void circularOffset::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.circularOffset)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sequenceid_.ClearToEmpty();
  offset_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* circularOffset::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sequenceId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sequenceid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MATNew.circularOffset.sequenceId"));
        } else
          goto handle_unusual;
        continue;
      // int32 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* circularOffset::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.circularOffset)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sequenceId = 1;
  if (!this->_internal_sequenceid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequenceid().data(), static_cast<int>(this->_internal_sequenceid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.circularOffset.sequenceId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sequenceid(), target);
  }

  // int32 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.circularOffset)
  return target;
}

size_t circularOffset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.circularOffset)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sequenceId = 1;
  if (!this->_internal_sequenceid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequenceid());
  }

  // int32 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_offset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData circularOffset::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    circularOffset::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*circularOffset::GetClassData() const { return &_class_data_; }

void circularOffset::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<circularOffset *>(to)->MergeFrom(
      static_cast<const circularOffset &>(from));
}


void circularOffset::MergeFrom(const circularOffset& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.circularOffset)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sequenceid().empty()) {
    _internal_set_sequenceid(from._internal_sequenceid());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void circularOffset::CopyFrom(const circularOffset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.circularOffset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool circularOffset::IsInitialized() const {
  return true;
}

void circularOffset::InternalSwap(circularOffset* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequenceid_, lhs_arena,
      &other->sequenceid_, rhs_arena
  );
  swap(offset_, other->offset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata circularOffset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[6]);
}

// ===================================================================

class tree::_Internal {
 public:
  static const ::MATNew::blockGapList& blockgaps(const tree* msg);
};

const ::MATNew::blockGapList&
tree::_Internal::blockgaps(const tree* msg) {
  return *msg->blockgaps_;
}
tree::tree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nodes_(arena),
  consensusseqmap_(arena),
  gaps_(arena),
  circularsequences_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.tree)
}
tree::tree(const tree& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nodes_(from.nodes_),
      consensusseqmap_(from.consensusseqmap_),
      gaps_(from.gaps_),
      circularsequences_(from.circularsequences_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  newick_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    newick_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_newick().empty()) {
    newick_.Set(from._internal_newick(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_blockgaps()) {
    blockgaps_ = new ::MATNew::blockGapList(*from.blockgaps_);
  } else {
    blockgaps_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:MATNew.tree)
}

inline void tree::SharedCtor() {
newick_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  newick_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
blockgaps_ = nullptr;
}

tree::~tree() {
  // @@protoc_insertion_point(destructor:MATNew.tree)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void tree::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  newick_.Destroy();
  if (this != internal_default_instance()) delete blockgaps_;
}

void tree::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void tree::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.tree)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  consensusseqmap_.Clear();
  gaps_.Clear();
  circularsequences_.Clear();
  newick_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && blockgaps_ != nullptr) {
    delete blockgaps_;
  }
  blockgaps_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* tree::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string newick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newick();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MATNew.tree.newick"));
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.node nodes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.consensusSeqToBlockIds consensusSeqMap = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_consensusseqmap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.gapList gaps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gaps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .MATNew.blockGapList blockGaps = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_blockgaps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.circularOffset circularSequences = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_circularsequences(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* tree::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.tree)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string newick = 1;
  if (!this->_internal_newick().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newick().data(), static_cast<int>(this->_internal_newick().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.tree.newick");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newick(), target);
  }

  // repeated .MATNew.node nodes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .MATNew.consensusSeqToBlockIds consensusSeqMap = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_consensusseqmap_size()); i < n; i++) {
    const auto& repfield = this->_internal_consensusseqmap(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .MATNew.gapList gaps = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gaps_size()); i < n; i++) {
    const auto& repfield = this->_internal_gaps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .MATNew.blockGapList blockGaps = 6;
  if (this->_internal_has_blockgaps()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::blockgaps(this),
        _Internal::blockgaps(this).GetCachedSize(), target, stream);
  }

  // repeated .MATNew.circularOffset circularSequences = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_circularsequences_size()); i < n; i++) {
    const auto& repfield = this->_internal_circularsequences(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.tree)
  return target;
}

size_t tree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.tree)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MATNew.node nodes = 2;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .MATNew.consensusSeqToBlockIds consensusSeqMap = 4;
  total_size += 1UL * this->_internal_consensusseqmap_size();
  for (const auto& msg : this->consensusseqmap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .MATNew.gapList gaps = 5;
  total_size += 1UL * this->_internal_gaps_size();
  for (const auto& msg : this->gaps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .MATNew.circularOffset circularSequences = 7;
  total_size += 1UL * this->_internal_circularsequences_size();
  for (const auto& msg : this->circularsequences_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string newick = 1;
  if (!this->_internal_newick().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newick());
  }

  // .MATNew.blockGapList blockGaps = 6;
  if (this->_internal_has_blockgaps()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *blockgaps_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData tree::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    tree::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*tree::GetClassData() const { return &_class_data_; }

void tree::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<tree *>(to)->MergeFrom(
      static_cast<const tree &>(from));
}


void tree::MergeFrom(const tree& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.tree)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  consensusseqmap_.MergeFrom(from.consensusseqmap_);
  gaps_.MergeFrom(from.gaps_);
  circularsequences_.MergeFrom(from.circularsequences_);
  if (!from._internal_newick().empty()) {
    _internal_set_newick(from._internal_newick());
  }
  if (from._internal_has_blockgaps()) {
    _internal_mutable_blockgaps()->::MATNew::blockGapList::MergeFrom(from._internal_blockgaps());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void tree::CopyFrom(const tree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.tree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tree::IsInitialized() const {
  return true;
}

void tree::InternalSwap(tree* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nodes_.InternalSwap(&other->nodes_);
  consensusseqmap_.InternalSwap(&other->consensusseqmap_);
  gaps_.InternalSwap(&other->gaps_);
  circularsequences_.InternalSwap(&other->circularsequences_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &newick_, lhs_arena,
      &other->newick_, rhs_arena
  );
  swap(blockgaps_, other->blockgaps_);
}

::PROTOBUF_NAMESPACE_ID::Metadata tree::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[7]);
}

// ===================================================================

class complexMutation::_Internal {
 public:
};

complexMutation::complexMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.complexMutation)
}
complexMutation::complexMutation(const complexMutation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sequenceid1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequenceid1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequenceid1().empty()) {
    sequenceid1_.Set(from._internal_sequenceid1(), 
      GetArenaForAllocation());
  }
  sequenceid2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequenceid2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequenceid2().empty()) {
    sequenceid2_.Set(from._internal_sequenceid2(), 
      GetArenaForAllocation());
  }
  sequenceid3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sequenceid3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequenceid3().empty()) {
    sequenceid3_.Set(from._internal_sequenceid3(), 
      GetArenaForAllocation());
  }
  ::memcpy(&treeindex1_, &from.treeindex1_,
    static_cast<size_t>(reinterpret_cast<char*>(&nucgapexistend2_) -
    reinterpret_cast<char*>(&treeindex1_)) + sizeof(nucgapexistend2_));
  // @@protoc_insertion_point(copy_constructor:MATNew.complexMutation)
}

inline void complexMutation::SharedCtor() {
sequenceid1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequenceid1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sequenceid2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequenceid2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sequenceid3_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sequenceid3_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&treeindex1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&nucgapexistend2_) -
    reinterpret_cast<char*>(&treeindex1_)) + sizeof(nucgapexistend2_));
}

complexMutation::~complexMutation() {
  // @@protoc_insertion_point(destructor:MATNew.complexMutation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void complexMutation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sequenceid1_.Destroy();
  sequenceid2_.Destroy();
  sequenceid3_.Destroy();
}

void complexMutation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void complexMutation::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.complexMutation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sequenceid1_.ClearToEmpty();
  sequenceid2_.ClearToEmpty();
  sequenceid3_.ClearToEmpty();
  ::memset(&treeindex1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nucgapexistend2_) -
      reinterpret_cast<char*>(&treeindex1_)) + sizeof(nucgapexistend2_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* complexMutation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool mutationType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          mutationtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 treeIndex1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          treeindex1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 treeIndex2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          treeindex2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 treeIndex3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          treeindex3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sequenceId1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_sequenceid1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MATNew.complexMutation.sequenceId1"));
        } else
          goto handle_unusual;
        continue;
      // string sequenceId2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_sequenceid2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MATNew.complexMutation.sequenceId2"));
        } else
          goto handle_unusual;
        continue;
      // int64 blockIdStart1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          blockidstart1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExistStart1 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          blockgapexiststart1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucPositionStart1 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          nucpositionstart1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucGapPositionStart1 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          nucgappositionstart1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nucGapExistStart1 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          nucgapexiststart1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 blockIdEnd1 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          blockidend1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExistEnd1 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          blockgapexistend1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucPositionEnd1 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          nucpositionend1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucGapPositionEnd1 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          nucgappositionend1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nucGapExistEnd1 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          nucgapexistend1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 blockIdStart2 = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          blockidstart2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExistStart2 = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          blockgapexiststart2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucPositionStart2 = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          nucpositionstart2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucGapPositionStart2 = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          nucgappositionstart2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nucGapExistStart2 = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          nucgapexiststart2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 blockIdEnd2 = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          blockidend2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool blockGapExistEnd2 = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          blockgapexistend2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucPositionEnd2 = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          nucpositionend2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 nucGapPositionEnd2 = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          nucgappositionend2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nucGapExistEnd2 = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          nucgapexistend2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sequenceId3 = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_sequenceid3();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "MATNew.complexMutation.sequenceId3"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* complexMutation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.complexMutation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool mutationType = 1;
  if (this->_internal_mutationtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_mutationtype(), target);
  }

  // int32 treeIndex1 = 2;
  if (this->_internal_treeindex1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_treeindex1(), target);
  }

  // int32 treeIndex2 = 3;
  if (this->_internal_treeindex2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_treeindex2(), target);
  }

  // int32 treeIndex3 = 4;
  if (this->_internal_treeindex3() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_treeindex3(), target);
  }

  // string sequenceId1 = 5;
  if (!this->_internal_sequenceid1().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequenceid1().data(), static_cast<int>(this->_internal_sequenceid1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.complexMutation.sequenceId1");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_sequenceid1(), target);
  }

  // string sequenceId2 = 6;
  if (!this->_internal_sequenceid2().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequenceid2().data(), static_cast<int>(this->_internal_sequenceid2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.complexMutation.sequenceId2");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_sequenceid2(), target);
  }

  // int64 blockIdStart1 = 7;
  if (this->_internal_blockidstart1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_blockidstart1(), target);
  }

  // bool blockGapExistStart1 = 8;
  if (this->_internal_blockgapexiststart1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_blockgapexiststart1(), target);
  }

  // int32 nucPositionStart1 = 9;
  if (this->_internal_nucpositionstart1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_nucpositionstart1(), target);
  }

  // int32 nucGapPositionStart1 = 10;
  if (this->_internal_nucgappositionstart1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_nucgappositionstart1(), target);
  }

  // bool nucGapExistStart1 = 11;
  if (this->_internal_nucgapexiststart1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_nucgapexiststart1(), target);
  }

  // int64 blockIdEnd1 = 12;
  if (this->_internal_blockidend1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_blockidend1(), target);
  }

  // bool blockGapExistEnd1 = 13;
  if (this->_internal_blockgapexistend1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_blockgapexistend1(), target);
  }

  // int32 nucPositionEnd1 = 14;
  if (this->_internal_nucpositionend1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_nucpositionend1(), target);
  }

  // int32 nucGapPositionEnd1 = 15;
  if (this->_internal_nucgappositionend1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_nucgappositionend1(), target);
  }

  // bool nucGapExistEnd1 = 16;
  if (this->_internal_nucgapexistend1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_nucgapexistend1(), target);
  }

  // int64 blockIdStart2 = 17;
  if (this->_internal_blockidstart2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_blockidstart2(), target);
  }

  // bool blockGapExistStart2 = 18;
  if (this->_internal_blockgapexiststart2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_blockgapexiststart2(), target);
  }

  // int32 nucPositionStart2 = 19;
  if (this->_internal_nucpositionstart2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_nucpositionstart2(), target);
  }

  // int32 nucGapPositionStart2 = 20;
  if (this->_internal_nucgappositionstart2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_nucgappositionstart2(), target);
  }

  // bool nucGapExistStart2 = 21;
  if (this->_internal_nucgapexiststart2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_nucgapexiststart2(), target);
  }

  // int64 blockIdEnd2 = 22;
  if (this->_internal_blockidend2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(22, this->_internal_blockidend2(), target);
  }

  // bool blockGapExistEnd2 = 23;
  if (this->_internal_blockgapexistend2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_blockgapexistend2(), target);
  }

  // int32 nucPositionEnd2 = 24;
  if (this->_internal_nucpositionend2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_nucpositionend2(), target);
  }

  // int32 nucGapPositionEnd2 = 25;
  if (this->_internal_nucgappositionend2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_nucgappositionend2(), target);
  }

  // bool nucGapExistEnd2 = 26;
  if (this->_internal_nucgapexistend2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_nucgapexistend2(), target);
  }

  // string sequenceId3 = 27;
  if (!this->_internal_sequenceid3().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequenceid3().data(), static_cast<int>(this->_internal_sequenceid3().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MATNew.complexMutation.sequenceId3");
    target = stream->WriteStringMaybeAliased(
        27, this->_internal_sequenceid3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.complexMutation)
  return target;
}

size_t complexMutation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.complexMutation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sequenceId1 = 5;
  if (!this->_internal_sequenceid1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequenceid1());
  }

  // string sequenceId2 = 6;
  if (!this->_internal_sequenceid2().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequenceid2());
  }

  // string sequenceId3 = 27;
  if (!this->_internal_sequenceid3().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequenceid3());
  }

  // int32 treeIndex1 = 2;
  if (this->_internal_treeindex1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_treeindex1());
  }

  // int32 treeIndex2 = 3;
  if (this->_internal_treeindex2() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_treeindex2());
  }

  // int64 blockIdStart1 = 7;
  if (this->_internal_blockidstart1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_blockidstart1());
  }

  // int32 treeIndex3 = 4;
  if (this->_internal_treeindex3() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_treeindex3());
  }

  // bool mutationType = 1;
  if (this->_internal_mutationtype() != 0) {
    total_size += 1 + 1;
  }

  // bool blockGapExistStart1 = 8;
  if (this->_internal_blockgapexiststart1() != 0) {
    total_size += 1 + 1;
  }

  // bool nucGapExistStart1 = 11;
  if (this->_internal_nucgapexiststart1() != 0) {
    total_size += 1 + 1;
  }

  // bool blockGapExistEnd1 = 13;
  if (this->_internal_blockgapexistend1() != 0) {
    total_size += 1 + 1;
  }

  // int32 nucPositionStart1 = 9;
  if (this->_internal_nucpositionstart1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucpositionstart1());
  }

  // int32 nucGapPositionStart1 = 10;
  if (this->_internal_nucgappositionstart1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucgappositionstart1());
  }

  // int64 blockIdEnd1 = 12;
  if (this->_internal_blockidend1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_blockidend1());
  }

  // int32 nucPositionEnd1 = 14;
  if (this->_internal_nucpositionend1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucpositionend1());
  }

  // int32 nucGapPositionEnd1 = 15;
  if (this->_internal_nucgappositionend1() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nucgappositionend1());
  }

  // int64 blockIdStart2 = 17;
  if (this->_internal_blockidstart2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_blockidstart2());
  }

  // int32 nucPositionStart2 = 19;
  if (this->_internal_nucpositionstart2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_nucpositionstart2());
  }

  // bool nucGapExistEnd1 = 16;
  if (this->_internal_nucgapexistend1() != 0) {
    total_size += 2 + 1;
  }

  // bool blockGapExistStart2 = 18;
  if (this->_internal_blockgapexiststart2() != 0) {
    total_size += 2 + 1;
  }

  // bool nucGapExistStart2 = 21;
  if (this->_internal_nucgapexiststart2() != 0) {
    total_size += 2 + 1;
  }

  // bool blockGapExistEnd2 = 23;
  if (this->_internal_blockgapexistend2() != 0) {
    total_size += 2 + 1;
  }

  // int64 blockIdEnd2 = 22;
  if (this->_internal_blockidend2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_blockidend2());
  }

  // int32 nucGapPositionStart2 = 20;
  if (this->_internal_nucgappositionstart2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_nucgappositionstart2());
  }

  // int32 nucPositionEnd2 = 24;
  if (this->_internal_nucpositionend2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_nucpositionend2());
  }

  // int32 nucGapPositionEnd2 = 25;
  if (this->_internal_nucgappositionend2() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_nucgappositionend2());
  }

  // bool nucGapExistEnd2 = 26;
  if (this->_internal_nucgapexistend2() != 0) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData complexMutation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    complexMutation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*complexMutation::GetClassData() const { return &_class_data_; }

void complexMutation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<complexMutation *>(to)->MergeFrom(
      static_cast<const complexMutation &>(from));
}


void complexMutation::MergeFrom(const complexMutation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.complexMutation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sequenceid1().empty()) {
    _internal_set_sequenceid1(from._internal_sequenceid1());
  }
  if (!from._internal_sequenceid2().empty()) {
    _internal_set_sequenceid2(from._internal_sequenceid2());
  }
  if (!from._internal_sequenceid3().empty()) {
    _internal_set_sequenceid3(from._internal_sequenceid3());
  }
  if (from._internal_treeindex1() != 0) {
    _internal_set_treeindex1(from._internal_treeindex1());
  }
  if (from._internal_treeindex2() != 0) {
    _internal_set_treeindex2(from._internal_treeindex2());
  }
  if (from._internal_blockidstart1() != 0) {
    _internal_set_blockidstart1(from._internal_blockidstart1());
  }
  if (from._internal_treeindex3() != 0) {
    _internal_set_treeindex3(from._internal_treeindex3());
  }
  if (from._internal_mutationtype() != 0) {
    _internal_set_mutationtype(from._internal_mutationtype());
  }
  if (from._internal_blockgapexiststart1() != 0) {
    _internal_set_blockgapexiststart1(from._internal_blockgapexiststart1());
  }
  if (from._internal_nucgapexiststart1() != 0) {
    _internal_set_nucgapexiststart1(from._internal_nucgapexiststart1());
  }
  if (from._internal_blockgapexistend1() != 0) {
    _internal_set_blockgapexistend1(from._internal_blockgapexistend1());
  }
  if (from._internal_nucpositionstart1() != 0) {
    _internal_set_nucpositionstart1(from._internal_nucpositionstart1());
  }
  if (from._internal_nucgappositionstart1() != 0) {
    _internal_set_nucgappositionstart1(from._internal_nucgappositionstart1());
  }
  if (from._internal_blockidend1() != 0) {
    _internal_set_blockidend1(from._internal_blockidend1());
  }
  if (from._internal_nucpositionend1() != 0) {
    _internal_set_nucpositionend1(from._internal_nucpositionend1());
  }
  if (from._internal_nucgappositionend1() != 0) {
    _internal_set_nucgappositionend1(from._internal_nucgappositionend1());
  }
  if (from._internal_blockidstart2() != 0) {
    _internal_set_blockidstart2(from._internal_blockidstart2());
  }
  if (from._internal_nucpositionstart2() != 0) {
    _internal_set_nucpositionstart2(from._internal_nucpositionstart2());
  }
  if (from._internal_nucgapexistend1() != 0) {
    _internal_set_nucgapexistend1(from._internal_nucgapexistend1());
  }
  if (from._internal_blockgapexiststart2() != 0) {
    _internal_set_blockgapexiststart2(from._internal_blockgapexiststart2());
  }
  if (from._internal_nucgapexiststart2() != 0) {
    _internal_set_nucgapexiststart2(from._internal_nucgapexiststart2());
  }
  if (from._internal_blockgapexistend2() != 0) {
    _internal_set_blockgapexistend2(from._internal_blockgapexistend2());
  }
  if (from._internal_blockidend2() != 0) {
    _internal_set_blockidend2(from._internal_blockidend2());
  }
  if (from._internal_nucgappositionstart2() != 0) {
    _internal_set_nucgappositionstart2(from._internal_nucgappositionstart2());
  }
  if (from._internal_nucpositionend2() != 0) {
    _internal_set_nucpositionend2(from._internal_nucpositionend2());
  }
  if (from._internal_nucgappositionend2() != 0) {
    _internal_set_nucgappositionend2(from._internal_nucgappositionend2());
  }
  if (from._internal_nucgapexistend2() != 0) {
    _internal_set_nucgapexistend2(from._internal_nucgapexistend2());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void complexMutation::CopyFrom(const complexMutation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.complexMutation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool complexMutation::IsInitialized() const {
  return true;
}

void complexMutation::InternalSwap(complexMutation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequenceid1_, lhs_arena,
      &other->sequenceid1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequenceid2_, lhs_arena,
      &other->sequenceid2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sequenceid3_, lhs_arena,
      &other->sequenceid3_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(complexMutation, nucgapexistend2_)
      + sizeof(complexMutation::nucgapexistend2_)
      - PROTOBUF_FIELD_OFFSET(complexMutation, treeindex1_)>(
          reinterpret_cast<char*>(&treeindex1_),
          reinterpret_cast<char*>(&other->treeindex1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata complexMutation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[8]);
}

// ===================================================================

class treeGroup::_Internal {
 public:
};

treeGroup::treeGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trees_(arena),
  complexmutations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:MATNew.treeGroup)
}
treeGroup::treeGroup(const treeGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      trees_(from.trees_),
      complexmutations_(from.complexmutations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:MATNew.treeGroup)
}

inline void treeGroup::SharedCtor() {
}

treeGroup::~treeGroup() {
  // @@protoc_insertion_point(destructor:MATNew.treeGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void treeGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void treeGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void treeGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:MATNew.treeGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trees_.Clear();
  complexmutations_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* treeGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .MATNew.tree trees = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trees(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .MATNew.complexMutation complexMutations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_complexmutations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* treeGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MATNew.treeGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .MATNew.tree trees = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trees_size()); i < n; i++) {
    const auto& repfield = this->_internal_trees(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .MATNew.complexMutation complexMutations = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_complexmutations_size()); i < n; i++) {
    const auto& repfield = this->_internal_complexmutations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MATNew.treeGroup)
  return target;
}

size_t treeGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MATNew.treeGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MATNew.tree trees = 1;
  total_size += 1UL * this->_internal_trees_size();
  for (const auto& msg : this->trees_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .MATNew.complexMutation complexMutations = 2;
  total_size += 1UL * this->_internal_complexmutations_size();
  for (const auto& msg : this->complexmutations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData treeGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    treeGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*treeGroup::GetClassData() const { return &_class_data_; }

void treeGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<treeGroup *>(to)->MergeFrom(
      static_cast<const treeGroup &>(from));
}


void treeGroup::MergeFrom(const treeGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MATNew.treeGroup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trees_.MergeFrom(from.trees_);
  complexmutations_.MergeFrom(from.complexmutations_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void treeGroup::CopyFrom(const treeGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MATNew.treeGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool treeGroup::IsInitialized() const {
  return true;
}

void treeGroup::InternalSwap(treeGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  trees_.InternalSwap(&other->trees_);
  complexmutations_.InternalSwap(&other->complexmutations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata treeGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_getter, &descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto_once,
      file_level_metadata_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace MATNew
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::MATNew::nucMut*
Arena::CreateMaybeMessage< ::MATNew::nucMut >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::nucMut >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::mutation*
Arena::CreateMaybeMessage< ::MATNew::mutation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::mutation >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::node*
Arena::CreateMaybeMessage< ::MATNew::node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::node >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::consensusSeqToBlockIds*
Arena::CreateMaybeMessage< ::MATNew::consensusSeqToBlockIds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::consensusSeqToBlockIds >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::gapList*
Arena::CreateMaybeMessage< ::MATNew::gapList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::gapList >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::blockGapList*
Arena::CreateMaybeMessage< ::MATNew::blockGapList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::blockGapList >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::circularOffset*
Arena::CreateMaybeMessage< ::MATNew::circularOffset >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::circularOffset >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::tree*
Arena::CreateMaybeMessage< ::MATNew::tree >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::tree >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::complexMutation*
Arena::CreateMaybeMessage< ::MATNew::complexMutation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::complexMutation >(arena);
}
template<> PROTOBUF_NOINLINE ::MATNew::treeGroup*
Arena::CreateMaybeMessage< ::MATNew::treeGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MATNew::treeGroup >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
