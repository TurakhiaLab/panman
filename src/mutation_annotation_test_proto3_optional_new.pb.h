// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mutation_annotation_test_proto3_optional_new.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
namespace MATNew {
class blockGapList;
struct blockGapListDefaultTypeInternal;
extern blockGapListDefaultTypeInternal _blockGapList_default_instance_;
class circularOffset;
struct circularOffsetDefaultTypeInternal;
extern circularOffsetDefaultTypeInternal _circularOffset_default_instance_;
class complexMutation;
struct complexMutationDefaultTypeInternal;
extern complexMutationDefaultTypeInternal _complexMutation_default_instance_;
class consensusSeqToBlockIds;
struct consensusSeqToBlockIdsDefaultTypeInternal;
extern consensusSeqToBlockIdsDefaultTypeInternal _consensusSeqToBlockIds_default_instance_;
class gapList;
struct gapListDefaultTypeInternal;
extern gapListDefaultTypeInternal _gapList_default_instance_;
class mutation;
struct mutationDefaultTypeInternal;
extern mutationDefaultTypeInternal _mutation_default_instance_;
class node;
struct nodeDefaultTypeInternal;
extern nodeDefaultTypeInternal _node_default_instance_;
class nucMut;
struct nucMutDefaultTypeInternal;
extern nucMutDefaultTypeInternal _nucMut_default_instance_;
class tree;
struct treeDefaultTypeInternal;
extern treeDefaultTypeInternal _tree_default_instance_;
class treeGroup;
struct treeGroupDefaultTypeInternal;
extern treeGroupDefaultTypeInternal _treeGroup_default_instance_;
}  // namespace MATNew
PROTOBUF_NAMESPACE_OPEN
template<> ::MATNew::blockGapList* Arena::CreateMaybeMessage<::MATNew::blockGapList>(Arena*);
template<> ::MATNew::circularOffset* Arena::CreateMaybeMessage<::MATNew::circularOffset>(Arena*);
template<> ::MATNew::complexMutation* Arena::CreateMaybeMessage<::MATNew::complexMutation>(Arena*);
template<> ::MATNew::consensusSeqToBlockIds* Arena::CreateMaybeMessage<::MATNew::consensusSeqToBlockIds>(Arena*);
template<> ::MATNew::gapList* Arena::CreateMaybeMessage<::MATNew::gapList>(Arena*);
template<> ::MATNew::mutation* Arena::CreateMaybeMessage<::MATNew::mutation>(Arena*);
template<> ::MATNew::node* Arena::CreateMaybeMessage<::MATNew::node>(Arena*);
template<> ::MATNew::nucMut* Arena::CreateMaybeMessage<::MATNew::nucMut>(Arena*);
template<> ::MATNew::tree* Arena::CreateMaybeMessage<::MATNew::tree>(Arena*);
template<> ::MATNew::treeGroup* Arena::CreateMaybeMessage<::MATNew::treeGroup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MATNew {

// ===================================================================

class nucMut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.nucMut) */ {
 public:
  inline nucMut() : nucMut(nullptr) {}
  ~nucMut() override;
  explicit PROTOBUF_CONSTEXPR nucMut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  nucMut(const nucMut& from);
  nucMut(nucMut&& from) noexcept
    : nucMut() {
    *this = ::std::move(from);
  }

  inline nucMut& operator=(const nucMut& from) {
    CopyFrom(from);
    return *this;
  }
  inline nucMut& operator=(nucMut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const nucMut& default_instance() {
    return *internal_default_instance();
  }
  static inline const nucMut* internal_default_instance() {
    return reinterpret_cast<const nucMut*>(
               &_nucMut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(nucMut& a, nucMut& b) {
    a.Swap(&b);
  }
  inline void Swap(nucMut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(nucMut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  nucMut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<nucMut>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const nucMut& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const nucMut& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(nucMut* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.nucMut";
  }
  protected:
  explicit nucMut(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNucPositionFieldNumber = 1,
    kNucGapPositionFieldNumber = 2,
    kNucGapExistFieldNumber = 3,
    kMutInfoFieldNumber = 4,
  };
  // int32 nucPosition = 1;
  void clear_nucposition();
  int32_t nucposition() const;
  void set_nucposition(int32_t value);
  private:
  int32_t _internal_nucposition() const;
  void _internal_set_nucposition(int32_t value);
  public:

  // int32 nucGapPosition = 2;
  void clear_nucgapposition();
  int32_t nucgapposition() const;
  void set_nucgapposition(int32_t value);
  private:
  int32_t _internal_nucgapposition() const;
  void _internal_set_nucgapposition(int32_t value);
  public:

  // bool nucGapExist = 3;
  void clear_nucgapexist();
  bool nucgapexist() const;
  void set_nucgapexist(bool value);
  private:
  bool _internal_nucgapexist() const;
  void _internal_set_nucgapexist(bool value);
  public:

  // uint32 mutInfo = 4;
  void clear_mutinfo();
  uint32_t mutinfo() const;
  void set_mutinfo(uint32_t value);
  private:
  uint32_t _internal_mutinfo() const;
  void _internal_set_mutinfo(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MATNew.nucMut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t nucposition_;
  int32_t nucgapposition_;
  bool nucgapexist_;
  uint32_t mutinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class mutation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.mutation) */ {
 public:
  inline mutation() : mutation(nullptr) {}
  ~mutation() override;
  explicit PROTOBUF_CONSTEXPR mutation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mutation(const mutation& from);
  mutation(mutation&& from) noexcept
    : mutation() {
    *this = ::std::move(from);
  }

  inline mutation& operator=(const mutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline mutation& operator=(mutation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mutation& default_instance() {
    return *internal_default_instance();
  }
  static inline const mutation* internal_default_instance() {
    return reinterpret_cast<const mutation*>(
               &_mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(mutation& a, mutation& b) {
    a.Swap(&b);
  }
  inline void Swap(mutation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mutation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mutation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const mutation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mutation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.mutation";
  }
  protected:
  explicit mutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNucMutationFieldNumber = 6,
    kBlockIdFieldNumber = 1,
    kBlockGapExistFieldNumber = 2,
    kBlockMutExistFieldNumber = 3,
    kBlockMutInfoFieldNumber = 4,
    kBlockInversionFieldNumber = 5,
  };
  // repeated .MATNew.nucMut nucMutation = 6;
  int nucmutation_size() const;
  private:
  int _internal_nucmutation_size() const;
  public:
  void clear_nucmutation();
  ::MATNew::nucMut* mutable_nucmutation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::nucMut >*
      mutable_nucmutation();
  private:
  const ::MATNew::nucMut& _internal_nucmutation(int index) const;
  ::MATNew::nucMut* _internal_add_nucmutation();
  public:
  const ::MATNew::nucMut& nucmutation(int index) const;
  ::MATNew::nucMut* add_nucmutation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::nucMut >&
      nucmutation() const;

  // int64 blockId = 1;
  void clear_blockid();
  int64_t blockid() const;
  void set_blockid(int64_t value);
  private:
  int64_t _internal_blockid() const;
  void _internal_set_blockid(int64_t value);
  public:

  // bool blockGapExist = 2;
  void clear_blockgapexist();
  bool blockgapexist() const;
  void set_blockgapexist(bool value);
  private:
  bool _internal_blockgapexist() const;
  void _internal_set_blockgapexist(bool value);
  public:

  // bool blockMutExist = 3;
  void clear_blockmutexist();
  bool blockmutexist() const;
  void set_blockmutexist(bool value);
  private:
  bool _internal_blockmutexist() const;
  void _internal_set_blockmutexist(bool value);
  public:

  // bool blockMutInfo = 4;
  void clear_blockmutinfo();
  bool blockmutinfo() const;
  void set_blockmutinfo(bool value);
  private:
  bool _internal_blockmutinfo() const;
  void _internal_set_blockmutinfo(bool value);
  public:

  // optional bool blockInversion = 5;
  bool has_blockinversion() const;
  private:
  bool _internal_has_blockinversion() const;
  public:
  void clear_blockinversion();
  bool blockinversion() const;
  void set_blockinversion(bool value);
  private:
  bool _internal_blockinversion() const;
  void _internal_set_blockinversion(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MATNew.mutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::nucMut > nucmutation_;
  int64_t blockid_;
  bool blockgapexist_;
  bool blockmutexist_;
  bool blockmutinfo_;
  bool blockinversion_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.node) */ {
 public:
  inline node() : node(nullptr) {}
  ~node() override;
  explicit PROTOBUF_CONSTEXPR node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  node(const node& from);
  node(node&& from) noexcept
    : node() {
    *this = ::std::move(from);
  }

  inline node& operator=(const node& from) {
    CopyFrom(from);
    return *this;
  }
  inline node& operator=(node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const node& default_instance() {
    return *internal_default_instance();
  }
  static inline const node* internal_default_instance() {
    return reinterpret_cast<const node*>(
               &_node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(node& a, node& b) {
    a.Swap(&b);
  }
  inline void Swap(node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const node& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.node";
  }
  protected:
  explicit node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutationsFieldNumber = 1,
    kAnnotationsFieldNumber = 2,
  };
  // repeated .MATNew.mutation mutations = 1;
  int mutations_size() const;
  private:
  int _internal_mutations_size() const;
  public:
  void clear_mutations();
  ::MATNew::mutation* mutable_mutations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::mutation >*
      mutable_mutations();
  private:
  const ::MATNew::mutation& _internal_mutations(int index) const;
  ::MATNew::mutation* _internal_add_mutations();
  public:
  const ::MATNew::mutation& mutations(int index) const;
  ::MATNew::mutation* add_mutations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::mutation >&
      mutations() const;

  // repeated string annotations = 2;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  const std::string& annotations(int index) const;
  std::string* mutable_annotations(int index);
  void set_annotations(int index, const std::string& value);
  void set_annotations(int index, std::string&& value);
  void set_annotations(int index, const char* value);
  void set_annotations(int index, const char* value, size_t size);
  std::string* add_annotations();
  void add_annotations(const std::string& value);
  void add_annotations(std::string&& value);
  void add_annotations(const char* value);
  void add_annotations(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& annotations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_annotations();
  private:
  const std::string& _internal_annotations(int index) const;
  std::string* _internal_add_annotations();
  public:

  // @@protoc_insertion_point(class_scope:MATNew.node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::mutation > mutations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> annotations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class consensusSeqToBlockIds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.consensusSeqToBlockIds) */ {
 public:
  inline consensusSeqToBlockIds() : consensusSeqToBlockIds(nullptr) {}
  ~consensusSeqToBlockIds() override;
  explicit PROTOBUF_CONSTEXPR consensusSeqToBlockIds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  consensusSeqToBlockIds(const consensusSeqToBlockIds& from);
  consensusSeqToBlockIds(consensusSeqToBlockIds&& from) noexcept
    : consensusSeqToBlockIds() {
    *this = ::std::move(from);
  }

  inline consensusSeqToBlockIds& operator=(const consensusSeqToBlockIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline consensusSeqToBlockIds& operator=(consensusSeqToBlockIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const consensusSeqToBlockIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const consensusSeqToBlockIds* internal_default_instance() {
    return reinterpret_cast<const consensusSeqToBlockIds*>(
               &_consensusSeqToBlockIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(consensusSeqToBlockIds& a, consensusSeqToBlockIds& b) {
    a.Swap(&b);
  }
  inline void Swap(consensusSeqToBlockIds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(consensusSeqToBlockIds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  consensusSeqToBlockIds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<consensusSeqToBlockIds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const consensusSeqToBlockIds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const consensusSeqToBlockIds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(consensusSeqToBlockIds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.consensusSeqToBlockIds";
  }
  protected:
  explicit consensusSeqToBlockIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kConsensusSeqFieldNumber = 2,
    kBlockGapExistFieldNumber = 3,
    kChromosomeNameFieldNumber = 4,
  };
  // repeated int64 blockId = 1;
  int blockid_size() const;
  private:
  int _internal_blockid_size() const;
  public:
  void clear_blockid();
  private:
  int64_t _internal_blockid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_blockid() const;
  void _internal_add_blockid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_blockid();
  public:
  int64_t blockid(int index) const;
  void set_blockid(int index, int64_t value);
  void add_blockid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      blockid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_blockid();

  // repeated uint32 consensusSeq = 2;
  int consensusseq_size() const;
  private:
  int _internal_consensusseq_size() const;
  public:
  void clear_consensusseq();
  private:
  uint32_t _internal_consensusseq(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_consensusseq() const;
  void _internal_add_consensusseq(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_consensusseq();
  public:
  uint32_t consensusseq(int index) const;
  void set_consensusseq(int index, uint32_t value);
  void add_consensusseq(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      consensusseq() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_consensusseq();

  // repeated bool blockGapExist = 3;
  int blockgapexist_size() const;
  private:
  int _internal_blockgapexist_size() const;
  public:
  void clear_blockgapexist();
  private:
  bool _internal_blockgapexist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_blockgapexist() const;
  void _internal_add_blockgapexist(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_blockgapexist();
  public:
  bool blockgapexist(int index) const;
  void set_blockgapexist(int index, bool value);
  void add_blockgapexist(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      blockgapexist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_blockgapexist();

  // repeated string chromosomeName = 4;
  int chromosomename_size() const;
  private:
  int _internal_chromosomename_size() const;
  public:
  void clear_chromosomename();
  const std::string& chromosomename(int index) const;
  std::string* mutable_chromosomename(int index);
  void set_chromosomename(int index, const std::string& value);
  void set_chromosomename(int index, std::string&& value);
  void set_chromosomename(int index, const char* value);
  void set_chromosomename(int index, const char* value, size_t size);
  std::string* add_chromosomename();
  void add_chromosomename(const std::string& value);
  void add_chromosomename(std::string&& value);
  void add_chromosomename(const char* value);
  void add_chromosomename(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& chromosomename() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_chromosomename();
  private:
  const std::string& _internal_chromosomename(int index) const;
  std::string* _internal_add_chromosomename();
  public:

  // @@protoc_insertion_point(class_scope:MATNew.consensusSeqToBlockIds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > blockid_;
  mutable std::atomic<int> _blockid_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > consensusseq_;
  mutable std::atomic<int> _consensusseq_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > blockgapexist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> chromosomename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class gapList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.gapList) */ {
 public:
  inline gapList() : gapList(nullptr) {}
  ~gapList() override;
  explicit PROTOBUF_CONSTEXPR gapList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  gapList(const gapList& from);
  gapList(gapList&& from) noexcept
    : gapList() {
    *this = ::std::move(from);
  }

  inline gapList& operator=(const gapList& from) {
    CopyFrom(from);
    return *this;
  }
  inline gapList& operator=(gapList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const gapList& default_instance() {
    return *internal_default_instance();
  }
  static inline const gapList* internal_default_instance() {
    return reinterpret_cast<const gapList*>(
               &_gapList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(gapList& a, gapList& b) {
    a.Swap(&b);
  }
  inline void Swap(gapList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(gapList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  gapList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<gapList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const gapList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const gapList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gapList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.gapList";
  }
  protected:
  explicit gapList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNucGapLengthFieldNumber = 3,
    kNucPositionFieldNumber = 4,
    kBlockIdFieldNumber = 1,
    kBlockGapExistFieldNumber = 2,
  };
  // repeated int32 nucGapLength = 3;
  int nucgaplength_size() const;
  private:
  int _internal_nucgaplength_size() const;
  public:
  void clear_nucgaplength();
  private:
  int32_t _internal_nucgaplength(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_nucgaplength() const;
  void _internal_add_nucgaplength(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_nucgaplength();
  public:
  int32_t nucgaplength(int index) const;
  void set_nucgaplength(int index, int32_t value);
  void add_nucgaplength(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      nucgaplength() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_nucgaplength();

  // repeated int32 nucPosition = 4;
  int nucposition_size() const;
  private:
  int _internal_nucposition_size() const;
  public:
  void clear_nucposition();
  private:
  int32_t _internal_nucposition(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_nucposition() const;
  void _internal_add_nucposition(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_nucposition();
  public:
  int32_t nucposition(int index) const;
  void set_nucposition(int index, int32_t value);
  void add_nucposition(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      nucposition() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_nucposition();

  // int64 blockId = 1;
  void clear_blockid();
  int64_t blockid() const;
  void set_blockid(int64_t value);
  private:
  int64_t _internal_blockid() const;
  void _internal_set_blockid(int64_t value);
  public:

  // bool blockGapExist = 2;
  void clear_blockgapexist();
  bool blockgapexist() const;
  void set_blockgapexist(bool value);
  private:
  bool _internal_blockgapexist() const;
  void _internal_set_blockgapexist(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MATNew.gapList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > nucgaplength_;
  mutable std::atomic<int> _nucgaplength_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > nucposition_;
  mutable std::atomic<int> _nucposition_cached_byte_size_;
  int64_t blockid_;
  bool blockgapexist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class blockGapList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.blockGapList) */ {
 public:
  inline blockGapList() : blockGapList(nullptr) {}
  ~blockGapList() override;
  explicit PROTOBUF_CONSTEXPR blockGapList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  blockGapList(const blockGapList& from);
  blockGapList(blockGapList&& from) noexcept
    : blockGapList() {
    *this = ::std::move(from);
  }

  inline blockGapList& operator=(const blockGapList& from) {
    CopyFrom(from);
    return *this;
  }
  inline blockGapList& operator=(blockGapList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const blockGapList& default_instance() {
    return *internal_default_instance();
  }
  static inline const blockGapList* internal_default_instance() {
    return reinterpret_cast<const blockGapList*>(
               &_blockGapList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(blockGapList& a, blockGapList& b) {
    a.Swap(&b);
  }
  inline void Swap(blockGapList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(blockGapList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  blockGapList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<blockGapList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const blockGapList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const blockGapList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(blockGapList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.blockGapList";
  }
  protected:
  explicit blockGapList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockPositionFieldNumber = 1,
    kBlockGapLengthFieldNumber = 2,
  };
  // repeated int32 blockPosition = 1;
  int blockposition_size() const;
  private:
  int _internal_blockposition_size() const;
  public:
  void clear_blockposition();
  private:
  int32_t _internal_blockposition(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_blockposition() const;
  void _internal_add_blockposition(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_blockposition();
  public:
  int32_t blockposition(int index) const;
  void set_blockposition(int index, int32_t value);
  void add_blockposition(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      blockposition() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_blockposition();

  // repeated int32 blockGapLength = 2;
  int blockgaplength_size() const;
  private:
  int _internal_blockgaplength_size() const;
  public:
  void clear_blockgaplength();
  private:
  int32_t _internal_blockgaplength(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_blockgaplength() const;
  void _internal_add_blockgaplength(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_blockgaplength();
  public:
  int32_t blockgaplength(int index) const;
  void set_blockgaplength(int index, int32_t value);
  void add_blockgaplength(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      blockgaplength() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_blockgaplength();

  // @@protoc_insertion_point(class_scope:MATNew.blockGapList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > blockposition_;
  mutable std::atomic<int> _blockposition_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > blockgaplength_;
  mutable std::atomic<int> _blockgaplength_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class circularOffset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.circularOffset) */ {
 public:
  inline circularOffset() : circularOffset(nullptr) {}
  ~circularOffset() override;
  explicit PROTOBUF_CONSTEXPR circularOffset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  circularOffset(const circularOffset& from);
  circularOffset(circularOffset&& from) noexcept
    : circularOffset() {
    *this = ::std::move(from);
  }

  inline circularOffset& operator=(const circularOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline circularOffset& operator=(circularOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const circularOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const circularOffset* internal_default_instance() {
    return reinterpret_cast<const circularOffset*>(
               &_circularOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(circularOffset& a, circularOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(circularOffset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(circularOffset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  circularOffset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<circularOffset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const circularOffset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const circularOffset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(circularOffset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.circularOffset";
  }
  protected:
  explicit circularOffset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // string sequenceId = 1;
  void clear_sequenceid();
  const std::string& sequenceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceid();
  PROTOBUF_NODISCARD std::string* release_sequenceid();
  void set_allocated_sequenceid(std::string* sequenceid);
  private:
  const std::string& _internal_sequenceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceid(const std::string& value);
  std::string* _internal_mutable_sequenceid();
  public:

  // int32 offset = 2;
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MATNew.circularOffset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceid_;
  int32_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class tree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.tree) */ {
 public:
  inline tree() : tree(nullptr) {}
  ~tree() override;
  explicit PROTOBUF_CONSTEXPR tree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  tree(const tree& from);
  tree(tree&& from) noexcept
    : tree() {
    *this = ::std::move(from);
  }

  inline tree& operator=(const tree& from) {
    CopyFrom(from);
    return *this;
  }
  inline tree& operator=(tree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const tree& default_instance() {
    return *internal_default_instance();
  }
  static inline const tree* internal_default_instance() {
    return reinterpret_cast<const tree*>(
               &_tree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(tree& a, tree& b) {
    a.Swap(&b);
  }
  inline void Swap(tree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(tree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  tree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<tree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const tree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const tree& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.tree";
  }
  protected:
  explicit tree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kConsensusSeqMapFieldNumber = 4,
    kGapsFieldNumber = 5,
    kCircularSequencesFieldNumber = 7,
    kNewickFieldNumber = 1,
    kBlockGapsFieldNumber = 6,
  };
  // repeated .MATNew.node nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::MATNew::node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::node >*
      mutable_nodes();
  private:
  const ::MATNew::node& _internal_nodes(int index) const;
  ::MATNew::node* _internal_add_nodes();
  public:
  const ::MATNew::node& nodes(int index) const;
  ::MATNew::node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::node >&
      nodes() const;

  // repeated .MATNew.consensusSeqToBlockIds consensusSeqMap = 4;
  int consensusseqmap_size() const;
  private:
  int _internal_consensusseqmap_size() const;
  public:
  void clear_consensusseqmap();
  ::MATNew::consensusSeqToBlockIds* mutable_consensusseqmap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::consensusSeqToBlockIds >*
      mutable_consensusseqmap();
  private:
  const ::MATNew::consensusSeqToBlockIds& _internal_consensusseqmap(int index) const;
  ::MATNew::consensusSeqToBlockIds* _internal_add_consensusseqmap();
  public:
  const ::MATNew::consensusSeqToBlockIds& consensusseqmap(int index) const;
  ::MATNew::consensusSeqToBlockIds* add_consensusseqmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::consensusSeqToBlockIds >&
      consensusseqmap() const;

  // repeated .MATNew.gapList gaps = 5;
  int gaps_size() const;
  private:
  int _internal_gaps_size() const;
  public:
  void clear_gaps();
  ::MATNew::gapList* mutable_gaps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::gapList >*
      mutable_gaps();
  private:
  const ::MATNew::gapList& _internal_gaps(int index) const;
  ::MATNew::gapList* _internal_add_gaps();
  public:
  const ::MATNew::gapList& gaps(int index) const;
  ::MATNew::gapList* add_gaps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::gapList >&
      gaps() const;

  // repeated .MATNew.circularOffset circularSequences = 7;
  int circularsequences_size() const;
  private:
  int _internal_circularsequences_size() const;
  public:
  void clear_circularsequences();
  ::MATNew::circularOffset* mutable_circularsequences(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::circularOffset >*
      mutable_circularsequences();
  private:
  const ::MATNew::circularOffset& _internal_circularsequences(int index) const;
  ::MATNew::circularOffset* _internal_add_circularsequences();
  public:
  const ::MATNew::circularOffset& circularsequences(int index) const;
  ::MATNew::circularOffset* add_circularsequences();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::circularOffset >&
      circularsequences() const;

  // string newick = 1;
  void clear_newick();
  const std::string& newick() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newick(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newick();
  PROTOBUF_NODISCARD std::string* release_newick();
  void set_allocated_newick(std::string* newick);
  private:
  const std::string& _internal_newick() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newick(const std::string& value);
  std::string* _internal_mutable_newick();
  public:

  // .MATNew.blockGapList blockGaps = 6;
  bool has_blockgaps() const;
  private:
  bool _internal_has_blockgaps() const;
  public:
  void clear_blockgaps();
  const ::MATNew::blockGapList& blockgaps() const;
  PROTOBUF_NODISCARD ::MATNew::blockGapList* release_blockgaps();
  ::MATNew::blockGapList* mutable_blockgaps();
  void set_allocated_blockgaps(::MATNew::blockGapList* blockgaps);
  private:
  const ::MATNew::blockGapList& _internal_blockgaps() const;
  ::MATNew::blockGapList* _internal_mutable_blockgaps();
  public:
  void unsafe_arena_set_allocated_blockgaps(
      ::MATNew::blockGapList* blockgaps);
  ::MATNew::blockGapList* unsafe_arena_release_blockgaps();

  // @@protoc_insertion_point(class_scope:MATNew.tree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::node > nodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::consensusSeqToBlockIds > consensusseqmap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::gapList > gaps_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::circularOffset > circularsequences_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newick_;
  ::MATNew::blockGapList* blockgaps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class complexMutation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.complexMutation) */ {
 public:
  inline complexMutation() : complexMutation(nullptr) {}
  ~complexMutation() override;
  explicit PROTOBUF_CONSTEXPR complexMutation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  complexMutation(const complexMutation& from);
  complexMutation(complexMutation&& from) noexcept
    : complexMutation() {
    *this = ::std::move(from);
  }

  inline complexMutation& operator=(const complexMutation& from) {
    CopyFrom(from);
    return *this;
  }
  inline complexMutation& operator=(complexMutation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const complexMutation& default_instance() {
    return *internal_default_instance();
  }
  static inline const complexMutation* internal_default_instance() {
    return reinterpret_cast<const complexMutation*>(
               &_complexMutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(complexMutation& a, complexMutation& b) {
    a.Swap(&b);
  }
  inline void Swap(complexMutation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(complexMutation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  complexMutation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<complexMutation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const complexMutation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const complexMutation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(complexMutation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.complexMutation";
  }
  protected:
  explicit complexMutation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceId1FieldNumber = 5,
    kSequenceId2FieldNumber = 6,
    kSequenceId3FieldNumber = 27,
    kTreeIndex1FieldNumber = 2,
    kTreeIndex2FieldNumber = 3,
    kBlockIdStart1FieldNumber = 7,
    kTreeIndex3FieldNumber = 4,
    kMutationTypeFieldNumber = 1,
    kBlockGapExistStart1FieldNumber = 8,
    kNucGapExistStart1FieldNumber = 11,
    kBlockGapExistEnd1FieldNumber = 13,
    kNucPositionStart1FieldNumber = 9,
    kNucGapPositionStart1FieldNumber = 10,
    kBlockIdEnd1FieldNumber = 12,
    kNucPositionEnd1FieldNumber = 14,
    kNucGapPositionEnd1FieldNumber = 15,
    kBlockIdStart2FieldNumber = 17,
    kNucPositionStart2FieldNumber = 19,
    kNucGapExistEnd1FieldNumber = 16,
    kBlockGapExistStart2FieldNumber = 18,
    kNucGapExistStart2FieldNumber = 21,
    kBlockGapExistEnd2FieldNumber = 23,
    kBlockIdEnd2FieldNumber = 22,
    kNucGapPositionStart2FieldNumber = 20,
    kNucPositionEnd2FieldNumber = 24,
    kNucGapPositionEnd2FieldNumber = 25,
    kNucGapExistEnd2FieldNumber = 26,
  };
  // string sequenceId1 = 5;
  void clear_sequenceid1();
  const std::string& sequenceid1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceid1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceid1();
  PROTOBUF_NODISCARD std::string* release_sequenceid1();
  void set_allocated_sequenceid1(std::string* sequenceid1);
  private:
  const std::string& _internal_sequenceid1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceid1(const std::string& value);
  std::string* _internal_mutable_sequenceid1();
  public:

  // string sequenceId2 = 6;
  void clear_sequenceid2();
  const std::string& sequenceid2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceid2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceid2();
  PROTOBUF_NODISCARD std::string* release_sequenceid2();
  void set_allocated_sequenceid2(std::string* sequenceid2);
  private:
  const std::string& _internal_sequenceid2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceid2(const std::string& value);
  std::string* _internal_mutable_sequenceid2();
  public:

  // string sequenceId3 = 27;
  void clear_sequenceid3();
  const std::string& sequenceid3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequenceid3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequenceid3();
  PROTOBUF_NODISCARD std::string* release_sequenceid3();
  void set_allocated_sequenceid3(std::string* sequenceid3);
  private:
  const std::string& _internal_sequenceid3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequenceid3(const std::string& value);
  std::string* _internal_mutable_sequenceid3();
  public:

  // int32 treeIndex1 = 2;
  void clear_treeindex1();
  int32_t treeindex1() const;
  void set_treeindex1(int32_t value);
  private:
  int32_t _internal_treeindex1() const;
  void _internal_set_treeindex1(int32_t value);
  public:

  // int32 treeIndex2 = 3;
  void clear_treeindex2();
  int32_t treeindex2() const;
  void set_treeindex2(int32_t value);
  private:
  int32_t _internal_treeindex2() const;
  void _internal_set_treeindex2(int32_t value);
  public:

  // int64 blockIdStart1 = 7;
  void clear_blockidstart1();
  int64_t blockidstart1() const;
  void set_blockidstart1(int64_t value);
  private:
  int64_t _internal_blockidstart1() const;
  void _internal_set_blockidstart1(int64_t value);
  public:

  // int32 treeIndex3 = 4;
  void clear_treeindex3();
  int32_t treeindex3() const;
  void set_treeindex3(int32_t value);
  private:
  int32_t _internal_treeindex3() const;
  void _internal_set_treeindex3(int32_t value);
  public:

  // bool mutationType = 1;
  void clear_mutationtype();
  bool mutationtype() const;
  void set_mutationtype(bool value);
  private:
  bool _internal_mutationtype() const;
  void _internal_set_mutationtype(bool value);
  public:

  // bool blockGapExistStart1 = 8;
  void clear_blockgapexiststart1();
  bool blockgapexiststart1() const;
  void set_blockgapexiststart1(bool value);
  private:
  bool _internal_blockgapexiststart1() const;
  void _internal_set_blockgapexiststart1(bool value);
  public:

  // bool nucGapExistStart1 = 11;
  void clear_nucgapexiststart1();
  bool nucgapexiststart1() const;
  void set_nucgapexiststart1(bool value);
  private:
  bool _internal_nucgapexiststart1() const;
  void _internal_set_nucgapexiststart1(bool value);
  public:

  // bool blockGapExistEnd1 = 13;
  void clear_blockgapexistend1();
  bool blockgapexistend1() const;
  void set_blockgapexistend1(bool value);
  private:
  bool _internal_blockgapexistend1() const;
  void _internal_set_blockgapexistend1(bool value);
  public:

  // int32 nucPositionStart1 = 9;
  void clear_nucpositionstart1();
  int32_t nucpositionstart1() const;
  void set_nucpositionstart1(int32_t value);
  private:
  int32_t _internal_nucpositionstart1() const;
  void _internal_set_nucpositionstart1(int32_t value);
  public:

  // int32 nucGapPositionStart1 = 10;
  void clear_nucgappositionstart1();
  int32_t nucgappositionstart1() const;
  void set_nucgappositionstart1(int32_t value);
  private:
  int32_t _internal_nucgappositionstart1() const;
  void _internal_set_nucgappositionstart1(int32_t value);
  public:

  // int64 blockIdEnd1 = 12;
  void clear_blockidend1();
  int64_t blockidend1() const;
  void set_blockidend1(int64_t value);
  private:
  int64_t _internal_blockidend1() const;
  void _internal_set_blockidend1(int64_t value);
  public:

  // int32 nucPositionEnd1 = 14;
  void clear_nucpositionend1();
  int32_t nucpositionend1() const;
  void set_nucpositionend1(int32_t value);
  private:
  int32_t _internal_nucpositionend1() const;
  void _internal_set_nucpositionend1(int32_t value);
  public:

  // int32 nucGapPositionEnd1 = 15;
  void clear_nucgappositionend1();
  int32_t nucgappositionend1() const;
  void set_nucgappositionend1(int32_t value);
  private:
  int32_t _internal_nucgappositionend1() const;
  void _internal_set_nucgappositionend1(int32_t value);
  public:

  // int64 blockIdStart2 = 17;
  void clear_blockidstart2();
  int64_t blockidstart2() const;
  void set_blockidstart2(int64_t value);
  private:
  int64_t _internal_blockidstart2() const;
  void _internal_set_blockidstart2(int64_t value);
  public:

  // int32 nucPositionStart2 = 19;
  void clear_nucpositionstart2();
  int32_t nucpositionstart2() const;
  void set_nucpositionstart2(int32_t value);
  private:
  int32_t _internal_nucpositionstart2() const;
  void _internal_set_nucpositionstart2(int32_t value);
  public:

  // bool nucGapExistEnd1 = 16;
  void clear_nucgapexistend1();
  bool nucgapexistend1() const;
  void set_nucgapexistend1(bool value);
  private:
  bool _internal_nucgapexistend1() const;
  void _internal_set_nucgapexistend1(bool value);
  public:

  // bool blockGapExistStart2 = 18;
  void clear_blockgapexiststart2();
  bool blockgapexiststart2() const;
  void set_blockgapexiststart2(bool value);
  private:
  bool _internal_blockgapexiststart2() const;
  void _internal_set_blockgapexiststart2(bool value);
  public:

  // bool nucGapExistStart2 = 21;
  void clear_nucgapexiststart2();
  bool nucgapexiststart2() const;
  void set_nucgapexiststart2(bool value);
  private:
  bool _internal_nucgapexiststart2() const;
  void _internal_set_nucgapexiststart2(bool value);
  public:

  // bool blockGapExistEnd2 = 23;
  void clear_blockgapexistend2();
  bool blockgapexistend2() const;
  void set_blockgapexistend2(bool value);
  private:
  bool _internal_blockgapexistend2() const;
  void _internal_set_blockgapexistend2(bool value);
  public:

  // int64 blockIdEnd2 = 22;
  void clear_blockidend2();
  int64_t blockidend2() const;
  void set_blockidend2(int64_t value);
  private:
  int64_t _internal_blockidend2() const;
  void _internal_set_blockidend2(int64_t value);
  public:

  // int32 nucGapPositionStart2 = 20;
  void clear_nucgappositionstart2();
  int32_t nucgappositionstart2() const;
  void set_nucgappositionstart2(int32_t value);
  private:
  int32_t _internal_nucgappositionstart2() const;
  void _internal_set_nucgappositionstart2(int32_t value);
  public:

  // int32 nucPositionEnd2 = 24;
  void clear_nucpositionend2();
  int32_t nucpositionend2() const;
  void set_nucpositionend2(int32_t value);
  private:
  int32_t _internal_nucpositionend2() const;
  void _internal_set_nucpositionend2(int32_t value);
  public:

  // int32 nucGapPositionEnd2 = 25;
  void clear_nucgappositionend2();
  int32_t nucgappositionend2() const;
  void set_nucgappositionend2(int32_t value);
  private:
  int32_t _internal_nucgappositionend2() const;
  void _internal_set_nucgappositionend2(int32_t value);
  public:

  // bool nucGapExistEnd2 = 26;
  void clear_nucgapexistend2();
  bool nucgapexistend2() const;
  void set_nucgapexistend2(bool value);
  private:
  bool _internal_nucgapexistend2() const;
  void _internal_set_nucgapexistend2(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MATNew.complexMutation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceid1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceid2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequenceid3_;
  int32_t treeindex1_;
  int32_t treeindex2_;
  int64_t blockidstart1_;
  int32_t treeindex3_;
  bool mutationtype_;
  bool blockgapexiststart1_;
  bool nucgapexiststart1_;
  bool blockgapexistend1_;
  int32_t nucpositionstart1_;
  int32_t nucgappositionstart1_;
  int64_t blockidend1_;
  int32_t nucpositionend1_;
  int32_t nucgappositionend1_;
  int64_t blockidstart2_;
  int32_t nucpositionstart2_;
  bool nucgapexistend1_;
  bool blockgapexiststart2_;
  bool nucgapexiststart2_;
  bool blockgapexistend2_;
  int64_t blockidend2_;
  int32_t nucgappositionstart2_;
  int32_t nucpositionend2_;
  int32_t nucgappositionend2_;
  bool nucgapexistend2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// -------------------------------------------------------------------

class treeGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MATNew.treeGroup) */ {
 public:
  inline treeGroup() : treeGroup(nullptr) {}
  ~treeGroup() override;
  explicit PROTOBUF_CONSTEXPR treeGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  treeGroup(const treeGroup& from);
  treeGroup(treeGroup&& from) noexcept
    : treeGroup() {
    *this = ::std::move(from);
  }

  inline treeGroup& operator=(const treeGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline treeGroup& operator=(treeGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const treeGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const treeGroup* internal_default_instance() {
    return reinterpret_cast<const treeGroup*>(
               &_treeGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(treeGroup& a, treeGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(treeGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(treeGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  treeGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<treeGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const treeGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const treeGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(treeGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MATNew.treeGroup";
  }
  protected:
  explicit treeGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreesFieldNumber = 1,
    kComplexMutationsFieldNumber = 2,
  };
  // repeated .MATNew.tree trees = 1;
  int trees_size() const;
  private:
  int _internal_trees_size() const;
  public:
  void clear_trees();
  ::MATNew::tree* mutable_trees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::tree >*
      mutable_trees();
  private:
  const ::MATNew::tree& _internal_trees(int index) const;
  ::MATNew::tree* _internal_add_trees();
  public:
  const ::MATNew::tree& trees(int index) const;
  ::MATNew::tree* add_trees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::tree >&
      trees() const;

  // repeated .MATNew.complexMutation complexMutations = 2;
  int complexmutations_size() const;
  private:
  int _internal_complexmutations_size() const;
  public:
  void clear_complexmutations();
  ::MATNew::complexMutation* mutable_complexmutations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::complexMutation >*
      mutable_complexmutations();
  private:
  const ::MATNew::complexMutation& _internal_complexmutations(int index) const;
  ::MATNew::complexMutation* _internal_add_complexmutations();
  public:
  const ::MATNew::complexMutation& complexmutations(int index) const;
  ::MATNew::complexMutation* add_complexmutations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::complexMutation >&
      complexmutations() const;

  // @@protoc_insertion_point(class_scope:MATNew.treeGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::tree > trees_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::complexMutation > complexmutations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// nucMut

// int32 nucPosition = 1;
inline void nucMut::clear_nucposition() {
  nucposition_ = 0;
}
inline int32_t nucMut::_internal_nucposition() const {
  return nucposition_;
}
inline int32_t nucMut::nucposition() const {
  // @@protoc_insertion_point(field_get:MATNew.nucMut.nucPosition)
  return _internal_nucposition();
}
inline void nucMut::_internal_set_nucposition(int32_t value) {
  
  nucposition_ = value;
}
inline void nucMut::set_nucposition(int32_t value) {
  _internal_set_nucposition(value);
  // @@protoc_insertion_point(field_set:MATNew.nucMut.nucPosition)
}

// int32 nucGapPosition = 2;
inline void nucMut::clear_nucgapposition() {
  nucgapposition_ = 0;
}
inline int32_t nucMut::_internal_nucgapposition() const {
  return nucgapposition_;
}
inline int32_t nucMut::nucgapposition() const {
  // @@protoc_insertion_point(field_get:MATNew.nucMut.nucGapPosition)
  return _internal_nucgapposition();
}
inline void nucMut::_internal_set_nucgapposition(int32_t value) {
  
  nucgapposition_ = value;
}
inline void nucMut::set_nucgapposition(int32_t value) {
  _internal_set_nucgapposition(value);
  // @@protoc_insertion_point(field_set:MATNew.nucMut.nucGapPosition)
}

// bool nucGapExist = 3;
inline void nucMut::clear_nucgapexist() {
  nucgapexist_ = false;
}
inline bool nucMut::_internal_nucgapexist() const {
  return nucgapexist_;
}
inline bool nucMut::nucgapexist() const {
  // @@protoc_insertion_point(field_get:MATNew.nucMut.nucGapExist)
  return _internal_nucgapexist();
}
inline void nucMut::_internal_set_nucgapexist(bool value) {
  
  nucgapexist_ = value;
}
inline void nucMut::set_nucgapexist(bool value) {
  _internal_set_nucgapexist(value);
  // @@protoc_insertion_point(field_set:MATNew.nucMut.nucGapExist)
}

// uint32 mutInfo = 4;
inline void nucMut::clear_mutinfo() {
  mutinfo_ = 0u;
}
inline uint32_t nucMut::_internal_mutinfo() const {
  return mutinfo_;
}
inline uint32_t nucMut::mutinfo() const {
  // @@protoc_insertion_point(field_get:MATNew.nucMut.mutInfo)
  return _internal_mutinfo();
}
inline void nucMut::_internal_set_mutinfo(uint32_t value) {
  
  mutinfo_ = value;
}
inline void nucMut::set_mutinfo(uint32_t value) {
  _internal_set_mutinfo(value);
  // @@protoc_insertion_point(field_set:MATNew.nucMut.mutInfo)
}

// -------------------------------------------------------------------

// mutation

// int64 blockId = 1;
inline void mutation::clear_blockid() {
  blockid_ = int64_t{0};
}
inline int64_t mutation::_internal_blockid() const {
  return blockid_;
}
inline int64_t mutation::blockid() const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.blockId)
  return _internal_blockid();
}
inline void mutation::_internal_set_blockid(int64_t value) {
  
  blockid_ = value;
}
inline void mutation::set_blockid(int64_t value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:MATNew.mutation.blockId)
}

// bool blockGapExist = 2;
inline void mutation::clear_blockgapexist() {
  blockgapexist_ = false;
}
inline bool mutation::_internal_blockgapexist() const {
  return blockgapexist_;
}
inline bool mutation::blockgapexist() const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.blockGapExist)
  return _internal_blockgapexist();
}
inline void mutation::_internal_set_blockgapexist(bool value) {
  
  blockgapexist_ = value;
}
inline void mutation::set_blockgapexist(bool value) {
  _internal_set_blockgapexist(value);
  // @@protoc_insertion_point(field_set:MATNew.mutation.blockGapExist)
}

// bool blockMutExist = 3;
inline void mutation::clear_blockmutexist() {
  blockmutexist_ = false;
}
inline bool mutation::_internal_blockmutexist() const {
  return blockmutexist_;
}
inline bool mutation::blockmutexist() const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.blockMutExist)
  return _internal_blockmutexist();
}
inline void mutation::_internal_set_blockmutexist(bool value) {
  
  blockmutexist_ = value;
}
inline void mutation::set_blockmutexist(bool value) {
  _internal_set_blockmutexist(value);
  // @@protoc_insertion_point(field_set:MATNew.mutation.blockMutExist)
}

// bool blockMutInfo = 4;
inline void mutation::clear_blockmutinfo() {
  blockmutinfo_ = false;
}
inline bool mutation::_internal_blockmutinfo() const {
  return blockmutinfo_;
}
inline bool mutation::blockmutinfo() const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.blockMutInfo)
  return _internal_blockmutinfo();
}
inline void mutation::_internal_set_blockmutinfo(bool value) {
  
  blockmutinfo_ = value;
}
inline void mutation::set_blockmutinfo(bool value) {
  _internal_set_blockmutinfo(value);
  // @@protoc_insertion_point(field_set:MATNew.mutation.blockMutInfo)
}

// optional bool blockInversion = 5;
inline bool mutation::_internal_has_blockinversion() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mutation::has_blockinversion() const {
  return _internal_has_blockinversion();
}
inline void mutation::clear_blockinversion() {
  blockinversion_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool mutation::_internal_blockinversion() const {
  return blockinversion_;
}
inline bool mutation::blockinversion() const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.blockInversion)
  return _internal_blockinversion();
}
inline void mutation::_internal_set_blockinversion(bool value) {
  _has_bits_[0] |= 0x00000001u;
  blockinversion_ = value;
}
inline void mutation::set_blockinversion(bool value) {
  _internal_set_blockinversion(value);
  // @@protoc_insertion_point(field_set:MATNew.mutation.blockInversion)
}

// repeated .MATNew.nucMut nucMutation = 6;
inline int mutation::_internal_nucmutation_size() const {
  return nucmutation_.size();
}
inline int mutation::nucmutation_size() const {
  return _internal_nucmutation_size();
}
inline void mutation::clear_nucmutation() {
  nucmutation_.Clear();
}
inline ::MATNew::nucMut* mutation::mutable_nucmutation(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.mutation.nucMutation)
  return nucmutation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::nucMut >*
mutation::mutable_nucmutation() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.mutation.nucMutation)
  return &nucmutation_;
}
inline const ::MATNew::nucMut& mutation::_internal_nucmutation(int index) const {
  return nucmutation_.Get(index);
}
inline const ::MATNew::nucMut& mutation::nucmutation(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.mutation.nucMutation)
  return _internal_nucmutation(index);
}
inline ::MATNew::nucMut* mutation::_internal_add_nucmutation() {
  return nucmutation_.Add();
}
inline ::MATNew::nucMut* mutation::add_nucmutation() {
  ::MATNew::nucMut* _add = _internal_add_nucmutation();
  // @@protoc_insertion_point(field_add:MATNew.mutation.nucMutation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::nucMut >&
mutation::nucmutation() const {
  // @@protoc_insertion_point(field_list:MATNew.mutation.nucMutation)
  return nucmutation_;
}

// -------------------------------------------------------------------

// node

// repeated .MATNew.mutation mutations = 1;
inline int node::_internal_mutations_size() const {
  return mutations_.size();
}
inline int node::mutations_size() const {
  return _internal_mutations_size();
}
inline void node::clear_mutations() {
  mutations_.Clear();
}
inline ::MATNew::mutation* node::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.node.mutations)
  return mutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::mutation >*
node::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.node.mutations)
  return &mutations_;
}
inline const ::MATNew::mutation& node::_internal_mutations(int index) const {
  return mutations_.Get(index);
}
inline const ::MATNew::mutation& node::mutations(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.node.mutations)
  return _internal_mutations(index);
}
inline ::MATNew::mutation* node::_internal_add_mutations() {
  return mutations_.Add();
}
inline ::MATNew::mutation* node::add_mutations() {
  ::MATNew::mutation* _add = _internal_add_mutations();
  // @@protoc_insertion_point(field_add:MATNew.node.mutations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::mutation >&
node::mutations() const {
  // @@protoc_insertion_point(field_list:MATNew.node.mutations)
  return mutations_;
}

// repeated string annotations = 2;
inline int node::_internal_annotations_size() const {
  return annotations_.size();
}
inline int node::annotations_size() const {
  return _internal_annotations_size();
}
inline void node::clear_annotations() {
  annotations_.Clear();
}
inline std::string* node::add_annotations() {
  std::string* _s = _internal_add_annotations();
  // @@protoc_insertion_point(field_add_mutable:MATNew.node.annotations)
  return _s;
}
inline const std::string& node::_internal_annotations(int index) const {
  return annotations_.Get(index);
}
inline const std::string& node::annotations(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.node.annotations)
  return _internal_annotations(index);
}
inline std::string* node::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.node.annotations)
  return annotations_.Mutable(index);
}
inline void node::set_annotations(int index, const std::string& value) {
  annotations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:MATNew.node.annotations)
}
inline void node::set_annotations(int index, std::string&& value) {
  annotations_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:MATNew.node.annotations)
}
inline void node::set_annotations(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  annotations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MATNew.node.annotations)
}
inline void node::set_annotations(int index, const char* value, size_t size) {
  annotations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MATNew.node.annotations)
}
inline std::string* node::_internal_add_annotations() {
  return annotations_.Add();
}
inline void node::add_annotations(const std::string& value) {
  annotations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MATNew.node.annotations)
}
inline void node::add_annotations(std::string&& value) {
  annotations_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MATNew.node.annotations)
}
inline void node::add_annotations(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  annotations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MATNew.node.annotations)
}
inline void node::add_annotations(const char* value, size_t size) {
  annotations_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MATNew.node.annotations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
node::annotations() const {
  // @@protoc_insertion_point(field_list:MATNew.node.annotations)
  return annotations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
node::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.node.annotations)
  return &annotations_;
}

// -------------------------------------------------------------------

// consensusSeqToBlockIds

// repeated int64 blockId = 1;
inline int consensusSeqToBlockIds::_internal_blockid_size() const {
  return blockid_.size();
}
inline int consensusSeqToBlockIds::blockid_size() const {
  return _internal_blockid_size();
}
inline void consensusSeqToBlockIds::clear_blockid() {
  blockid_.Clear();
}
inline int64_t consensusSeqToBlockIds::_internal_blockid(int index) const {
  return blockid_.Get(index);
}
inline int64_t consensusSeqToBlockIds::blockid(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.consensusSeqToBlockIds.blockId)
  return _internal_blockid(index);
}
inline void consensusSeqToBlockIds::set_blockid(int index, int64_t value) {
  blockid_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.consensusSeqToBlockIds.blockId)
}
inline void consensusSeqToBlockIds::_internal_add_blockid(int64_t value) {
  blockid_.Add(value);
}
inline void consensusSeqToBlockIds::add_blockid(int64_t value) {
  _internal_add_blockid(value);
  // @@protoc_insertion_point(field_add:MATNew.consensusSeqToBlockIds.blockId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
consensusSeqToBlockIds::_internal_blockid() const {
  return blockid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
consensusSeqToBlockIds::blockid() const {
  // @@protoc_insertion_point(field_list:MATNew.consensusSeqToBlockIds.blockId)
  return _internal_blockid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
consensusSeqToBlockIds::_internal_mutable_blockid() {
  return &blockid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
consensusSeqToBlockIds::mutable_blockid() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.consensusSeqToBlockIds.blockId)
  return _internal_mutable_blockid();
}

// repeated uint32 consensusSeq = 2;
inline int consensusSeqToBlockIds::_internal_consensusseq_size() const {
  return consensusseq_.size();
}
inline int consensusSeqToBlockIds::consensusseq_size() const {
  return _internal_consensusseq_size();
}
inline void consensusSeqToBlockIds::clear_consensusseq() {
  consensusseq_.Clear();
}
inline uint32_t consensusSeqToBlockIds::_internal_consensusseq(int index) const {
  return consensusseq_.Get(index);
}
inline uint32_t consensusSeqToBlockIds::consensusseq(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.consensusSeqToBlockIds.consensusSeq)
  return _internal_consensusseq(index);
}
inline void consensusSeqToBlockIds::set_consensusseq(int index, uint32_t value) {
  consensusseq_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.consensusSeqToBlockIds.consensusSeq)
}
inline void consensusSeqToBlockIds::_internal_add_consensusseq(uint32_t value) {
  consensusseq_.Add(value);
}
inline void consensusSeqToBlockIds::add_consensusseq(uint32_t value) {
  _internal_add_consensusseq(value);
  // @@protoc_insertion_point(field_add:MATNew.consensusSeqToBlockIds.consensusSeq)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
consensusSeqToBlockIds::_internal_consensusseq() const {
  return consensusseq_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
consensusSeqToBlockIds::consensusseq() const {
  // @@protoc_insertion_point(field_list:MATNew.consensusSeqToBlockIds.consensusSeq)
  return _internal_consensusseq();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
consensusSeqToBlockIds::_internal_mutable_consensusseq() {
  return &consensusseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
consensusSeqToBlockIds::mutable_consensusseq() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.consensusSeqToBlockIds.consensusSeq)
  return _internal_mutable_consensusseq();
}

// repeated bool blockGapExist = 3;
inline int consensusSeqToBlockIds::_internal_blockgapexist_size() const {
  return blockgapexist_.size();
}
inline int consensusSeqToBlockIds::blockgapexist_size() const {
  return _internal_blockgapexist_size();
}
inline void consensusSeqToBlockIds::clear_blockgapexist() {
  blockgapexist_.Clear();
}
inline bool consensusSeqToBlockIds::_internal_blockgapexist(int index) const {
  return blockgapexist_.Get(index);
}
inline bool consensusSeqToBlockIds::blockgapexist(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.consensusSeqToBlockIds.blockGapExist)
  return _internal_blockgapexist(index);
}
inline void consensusSeqToBlockIds::set_blockgapexist(int index, bool value) {
  blockgapexist_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.consensusSeqToBlockIds.blockGapExist)
}
inline void consensusSeqToBlockIds::_internal_add_blockgapexist(bool value) {
  blockgapexist_.Add(value);
}
inline void consensusSeqToBlockIds::add_blockgapexist(bool value) {
  _internal_add_blockgapexist(value);
  // @@protoc_insertion_point(field_add:MATNew.consensusSeqToBlockIds.blockGapExist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
consensusSeqToBlockIds::_internal_blockgapexist() const {
  return blockgapexist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
consensusSeqToBlockIds::blockgapexist() const {
  // @@protoc_insertion_point(field_list:MATNew.consensusSeqToBlockIds.blockGapExist)
  return _internal_blockgapexist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
consensusSeqToBlockIds::_internal_mutable_blockgapexist() {
  return &blockgapexist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
consensusSeqToBlockIds::mutable_blockgapexist() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.consensusSeqToBlockIds.blockGapExist)
  return _internal_mutable_blockgapexist();
}

// repeated string chromosomeName = 4;
inline int consensusSeqToBlockIds::_internal_chromosomename_size() const {
  return chromosomename_.size();
}
inline int consensusSeqToBlockIds::chromosomename_size() const {
  return _internal_chromosomename_size();
}
inline void consensusSeqToBlockIds::clear_chromosomename() {
  chromosomename_.Clear();
}
inline std::string* consensusSeqToBlockIds::add_chromosomename() {
  std::string* _s = _internal_add_chromosomename();
  // @@protoc_insertion_point(field_add_mutable:MATNew.consensusSeqToBlockIds.chromosomeName)
  return _s;
}
inline const std::string& consensusSeqToBlockIds::_internal_chromosomename(int index) const {
  return chromosomename_.Get(index);
}
inline const std::string& consensusSeqToBlockIds::chromosomename(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.consensusSeqToBlockIds.chromosomeName)
  return _internal_chromosomename(index);
}
inline std::string* consensusSeqToBlockIds::mutable_chromosomename(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.consensusSeqToBlockIds.chromosomeName)
  return chromosomename_.Mutable(index);
}
inline void consensusSeqToBlockIds::set_chromosomename(int index, const std::string& value) {
  chromosomename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::set_chromosomename(int index, std::string&& value) {
  chromosomename_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::set_chromosomename(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chromosomename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::set_chromosomename(int index, const char* value, size_t size) {
  chromosomename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline std::string* consensusSeqToBlockIds::_internal_add_chromosomename() {
  return chromosomename_.Add();
}
inline void consensusSeqToBlockIds::add_chromosomename(const std::string& value) {
  chromosomename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::add_chromosomename(std::string&& value) {
  chromosomename_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::add_chromosomename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  chromosomename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline void consensusSeqToBlockIds::add_chromosomename(const char* value, size_t size) {
  chromosomename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MATNew.consensusSeqToBlockIds.chromosomeName)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
consensusSeqToBlockIds::chromosomename() const {
  // @@protoc_insertion_point(field_list:MATNew.consensusSeqToBlockIds.chromosomeName)
  return chromosomename_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
consensusSeqToBlockIds::mutable_chromosomename() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.consensusSeqToBlockIds.chromosomeName)
  return &chromosomename_;
}

// -------------------------------------------------------------------

// gapList

// int64 blockId = 1;
inline void gapList::clear_blockid() {
  blockid_ = int64_t{0};
}
inline int64_t gapList::_internal_blockid() const {
  return blockid_;
}
inline int64_t gapList::blockid() const {
  // @@protoc_insertion_point(field_get:MATNew.gapList.blockId)
  return _internal_blockid();
}
inline void gapList::_internal_set_blockid(int64_t value) {
  
  blockid_ = value;
}
inline void gapList::set_blockid(int64_t value) {
  _internal_set_blockid(value);
  // @@protoc_insertion_point(field_set:MATNew.gapList.blockId)
}

// bool blockGapExist = 2;
inline void gapList::clear_blockgapexist() {
  blockgapexist_ = false;
}
inline bool gapList::_internal_blockgapexist() const {
  return blockgapexist_;
}
inline bool gapList::blockgapexist() const {
  // @@protoc_insertion_point(field_get:MATNew.gapList.blockGapExist)
  return _internal_blockgapexist();
}
inline void gapList::_internal_set_blockgapexist(bool value) {
  
  blockgapexist_ = value;
}
inline void gapList::set_blockgapexist(bool value) {
  _internal_set_blockgapexist(value);
  // @@protoc_insertion_point(field_set:MATNew.gapList.blockGapExist)
}

// repeated int32 nucGapLength = 3;
inline int gapList::_internal_nucgaplength_size() const {
  return nucgaplength_.size();
}
inline int gapList::nucgaplength_size() const {
  return _internal_nucgaplength_size();
}
inline void gapList::clear_nucgaplength() {
  nucgaplength_.Clear();
}
inline int32_t gapList::_internal_nucgaplength(int index) const {
  return nucgaplength_.Get(index);
}
inline int32_t gapList::nucgaplength(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.gapList.nucGapLength)
  return _internal_nucgaplength(index);
}
inline void gapList::set_nucgaplength(int index, int32_t value) {
  nucgaplength_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.gapList.nucGapLength)
}
inline void gapList::_internal_add_nucgaplength(int32_t value) {
  nucgaplength_.Add(value);
}
inline void gapList::add_nucgaplength(int32_t value) {
  _internal_add_nucgaplength(value);
  // @@protoc_insertion_point(field_add:MATNew.gapList.nucGapLength)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
gapList::_internal_nucgaplength() const {
  return nucgaplength_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
gapList::nucgaplength() const {
  // @@protoc_insertion_point(field_list:MATNew.gapList.nucGapLength)
  return _internal_nucgaplength();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
gapList::_internal_mutable_nucgaplength() {
  return &nucgaplength_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
gapList::mutable_nucgaplength() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.gapList.nucGapLength)
  return _internal_mutable_nucgaplength();
}

// repeated int32 nucPosition = 4;
inline int gapList::_internal_nucposition_size() const {
  return nucposition_.size();
}
inline int gapList::nucposition_size() const {
  return _internal_nucposition_size();
}
inline void gapList::clear_nucposition() {
  nucposition_.Clear();
}
inline int32_t gapList::_internal_nucposition(int index) const {
  return nucposition_.Get(index);
}
inline int32_t gapList::nucposition(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.gapList.nucPosition)
  return _internal_nucposition(index);
}
inline void gapList::set_nucposition(int index, int32_t value) {
  nucposition_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.gapList.nucPosition)
}
inline void gapList::_internal_add_nucposition(int32_t value) {
  nucposition_.Add(value);
}
inline void gapList::add_nucposition(int32_t value) {
  _internal_add_nucposition(value);
  // @@protoc_insertion_point(field_add:MATNew.gapList.nucPosition)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
gapList::_internal_nucposition() const {
  return nucposition_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
gapList::nucposition() const {
  // @@protoc_insertion_point(field_list:MATNew.gapList.nucPosition)
  return _internal_nucposition();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
gapList::_internal_mutable_nucposition() {
  return &nucposition_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
gapList::mutable_nucposition() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.gapList.nucPosition)
  return _internal_mutable_nucposition();
}

// -------------------------------------------------------------------

// blockGapList

// repeated int32 blockPosition = 1;
inline int blockGapList::_internal_blockposition_size() const {
  return blockposition_.size();
}
inline int blockGapList::blockposition_size() const {
  return _internal_blockposition_size();
}
inline void blockGapList::clear_blockposition() {
  blockposition_.Clear();
}
inline int32_t blockGapList::_internal_blockposition(int index) const {
  return blockposition_.Get(index);
}
inline int32_t blockGapList::blockposition(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.blockGapList.blockPosition)
  return _internal_blockposition(index);
}
inline void blockGapList::set_blockposition(int index, int32_t value) {
  blockposition_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.blockGapList.blockPosition)
}
inline void blockGapList::_internal_add_blockposition(int32_t value) {
  blockposition_.Add(value);
}
inline void blockGapList::add_blockposition(int32_t value) {
  _internal_add_blockposition(value);
  // @@protoc_insertion_point(field_add:MATNew.blockGapList.blockPosition)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
blockGapList::_internal_blockposition() const {
  return blockposition_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
blockGapList::blockposition() const {
  // @@protoc_insertion_point(field_list:MATNew.blockGapList.blockPosition)
  return _internal_blockposition();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
blockGapList::_internal_mutable_blockposition() {
  return &blockposition_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
blockGapList::mutable_blockposition() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.blockGapList.blockPosition)
  return _internal_mutable_blockposition();
}

// repeated int32 blockGapLength = 2;
inline int blockGapList::_internal_blockgaplength_size() const {
  return blockgaplength_.size();
}
inline int blockGapList::blockgaplength_size() const {
  return _internal_blockgaplength_size();
}
inline void blockGapList::clear_blockgaplength() {
  blockgaplength_.Clear();
}
inline int32_t blockGapList::_internal_blockgaplength(int index) const {
  return blockgaplength_.Get(index);
}
inline int32_t blockGapList::blockgaplength(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.blockGapList.blockGapLength)
  return _internal_blockgaplength(index);
}
inline void blockGapList::set_blockgaplength(int index, int32_t value) {
  blockgaplength_.Set(index, value);
  // @@protoc_insertion_point(field_set:MATNew.blockGapList.blockGapLength)
}
inline void blockGapList::_internal_add_blockgaplength(int32_t value) {
  blockgaplength_.Add(value);
}
inline void blockGapList::add_blockgaplength(int32_t value) {
  _internal_add_blockgaplength(value);
  // @@protoc_insertion_point(field_add:MATNew.blockGapList.blockGapLength)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
blockGapList::_internal_blockgaplength() const {
  return blockgaplength_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
blockGapList::blockgaplength() const {
  // @@protoc_insertion_point(field_list:MATNew.blockGapList.blockGapLength)
  return _internal_blockgaplength();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
blockGapList::_internal_mutable_blockgaplength() {
  return &blockgaplength_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
blockGapList::mutable_blockgaplength() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.blockGapList.blockGapLength)
  return _internal_mutable_blockgaplength();
}

// -------------------------------------------------------------------

// circularOffset

// string sequenceId = 1;
inline void circularOffset::clear_sequenceid() {
  sequenceid_.ClearToEmpty();
}
inline const std::string& circularOffset::sequenceid() const {
  // @@protoc_insertion_point(field_get:MATNew.circularOffset.sequenceId)
  return _internal_sequenceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void circularOffset::set_sequenceid(ArgT0&& arg0, ArgT... args) {
 
 sequenceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MATNew.circularOffset.sequenceId)
}
inline std::string* circularOffset::mutable_sequenceid() {
  std::string* _s = _internal_mutable_sequenceid();
  // @@protoc_insertion_point(field_mutable:MATNew.circularOffset.sequenceId)
  return _s;
}
inline const std::string& circularOffset::_internal_sequenceid() const {
  return sequenceid_.Get();
}
inline void circularOffset::_internal_set_sequenceid(const std::string& value) {
  
  sequenceid_.Set(value, GetArenaForAllocation());
}
inline std::string* circularOffset::_internal_mutable_sequenceid() {
  
  return sequenceid_.Mutable(GetArenaForAllocation());
}
inline std::string* circularOffset::release_sequenceid() {
  // @@protoc_insertion_point(field_release:MATNew.circularOffset.sequenceId)
  return sequenceid_.Release();
}
inline void circularOffset::set_allocated_sequenceid(std::string* sequenceid) {
  if (sequenceid != nullptr) {
    
  } else {
    
  }
  sequenceid_.SetAllocated(sequenceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sequenceid_.IsDefault()) {
    sequenceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MATNew.circularOffset.sequenceId)
}

// int32 offset = 2;
inline void circularOffset::clear_offset() {
  offset_ = 0;
}
inline int32_t circularOffset::_internal_offset() const {
  return offset_;
}
inline int32_t circularOffset::offset() const {
  // @@protoc_insertion_point(field_get:MATNew.circularOffset.offset)
  return _internal_offset();
}
inline void circularOffset::_internal_set_offset(int32_t value) {
  
  offset_ = value;
}
inline void circularOffset::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:MATNew.circularOffset.offset)
}

// -------------------------------------------------------------------

// tree

// string newick = 1;
inline void tree::clear_newick() {
  newick_.ClearToEmpty();
}
inline const std::string& tree::newick() const {
  // @@protoc_insertion_point(field_get:MATNew.tree.newick)
  return _internal_newick();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void tree::set_newick(ArgT0&& arg0, ArgT... args) {
 
 newick_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MATNew.tree.newick)
}
inline std::string* tree::mutable_newick() {
  std::string* _s = _internal_mutable_newick();
  // @@protoc_insertion_point(field_mutable:MATNew.tree.newick)
  return _s;
}
inline const std::string& tree::_internal_newick() const {
  return newick_.Get();
}
inline void tree::_internal_set_newick(const std::string& value) {
  
  newick_.Set(value, GetArenaForAllocation());
}
inline std::string* tree::_internal_mutable_newick() {
  
  return newick_.Mutable(GetArenaForAllocation());
}
inline std::string* tree::release_newick() {
  // @@protoc_insertion_point(field_release:MATNew.tree.newick)
  return newick_.Release();
}
inline void tree::set_allocated_newick(std::string* newick) {
  if (newick != nullptr) {
    
  } else {
    
  }
  newick_.SetAllocated(newick, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (newick_.IsDefault()) {
    newick_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MATNew.tree.newick)
}

// repeated .MATNew.node nodes = 2;
inline int tree::_internal_nodes_size() const {
  return nodes_.size();
}
inline int tree::nodes_size() const {
  return _internal_nodes_size();
}
inline void tree::clear_nodes() {
  nodes_.Clear();
}
inline ::MATNew::node* tree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.tree.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::node >*
tree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.tree.nodes)
  return &nodes_;
}
inline const ::MATNew::node& tree::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::MATNew::node& tree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.tree.nodes)
  return _internal_nodes(index);
}
inline ::MATNew::node* tree::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::MATNew::node* tree::add_nodes() {
  ::MATNew::node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:MATNew.tree.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::node >&
tree::nodes() const {
  // @@protoc_insertion_point(field_list:MATNew.tree.nodes)
  return nodes_;
}

// repeated .MATNew.consensusSeqToBlockIds consensusSeqMap = 4;
inline int tree::_internal_consensusseqmap_size() const {
  return consensusseqmap_.size();
}
inline int tree::consensusseqmap_size() const {
  return _internal_consensusseqmap_size();
}
inline void tree::clear_consensusseqmap() {
  consensusseqmap_.Clear();
}
inline ::MATNew::consensusSeqToBlockIds* tree::mutable_consensusseqmap(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.tree.consensusSeqMap)
  return consensusseqmap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::consensusSeqToBlockIds >*
tree::mutable_consensusseqmap() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.tree.consensusSeqMap)
  return &consensusseqmap_;
}
inline const ::MATNew::consensusSeqToBlockIds& tree::_internal_consensusseqmap(int index) const {
  return consensusseqmap_.Get(index);
}
inline const ::MATNew::consensusSeqToBlockIds& tree::consensusseqmap(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.tree.consensusSeqMap)
  return _internal_consensusseqmap(index);
}
inline ::MATNew::consensusSeqToBlockIds* tree::_internal_add_consensusseqmap() {
  return consensusseqmap_.Add();
}
inline ::MATNew::consensusSeqToBlockIds* tree::add_consensusseqmap() {
  ::MATNew::consensusSeqToBlockIds* _add = _internal_add_consensusseqmap();
  // @@protoc_insertion_point(field_add:MATNew.tree.consensusSeqMap)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::consensusSeqToBlockIds >&
tree::consensusseqmap() const {
  // @@protoc_insertion_point(field_list:MATNew.tree.consensusSeqMap)
  return consensusseqmap_;
}

// repeated .MATNew.gapList gaps = 5;
inline int tree::_internal_gaps_size() const {
  return gaps_.size();
}
inline int tree::gaps_size() const {
  return _internal_gaps_size();
}
inline void tree::clear_gaps() {
  gaps_.Clear();
}
inline ::MATNew::gapList* tree::mutable_gaps(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.tree.gaps)
  return gaps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::gapList >*
tree::mutable_gaps() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.tree.gaps)
  return &gaps_;
}
inline const ::MATNew::gapList& tree::_internal_gaps(int index) const {
  return gaps_.Get(index);
}
inline const ::MATNew::gapList& tree::gaps(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.tree.gaps)
  return _internal_gaps(index);
}
inline ::MATNew::gapList* tree::_internal_add_gaps() {
  return gaps_.Add();
}
inline ::MATNew::gapList* tree::add_gaps() {
  ::MATNew::gapList* _add = _internal_add_gaps();
  // @@protoc_insertion_point(field_add:MATNew.tree.gaps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::gapList >&
tree::gaps() const {
  // @@protoc_insertion_point(field_list:MATNew.tree.gaps)
  return gaps_;
}

// .MATNew.blockGapList blockGaps = 6;
inline bool tree::_internal_has_blockgaps() const {
  return this != internal_default_instance() && blockgaps_ != nullptr;
}
inline bool tree::has_blockgaps() const {
  return _internal_has_blockgaps();
}
inline void tree::clear_blockgaps() {
  if (GetArenaForAllocation() == nullptr && blockgaps_ != nullptr) {
    delete blockgaps_;
  }
  blockgaps_ = nullptr;
}
inline const ::MATNew::blockGapList& tree::_internal_blockgaps() const {
  const ::MATNew::blockGapList* p = blockgaps_;
  return p != nullptr ? *p : reinterpret_cast<const ::MATNew::blockGapList&>(
      ::MATNew::_blockGapList_default_instance_);
}
inline const ::MATNew::blockGapList& tree::blockgaps() const {
  // @@protoc_insertion_point(field_get:MATNew.tree.blockGaps)
  return _internal_blockgaps();
}
inline void tree::unsafe_arena_set_allocated_blockgaps(
    ::MATNew::blockGapList* blockgaps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockgaps_);
  }
  blockgaps_ = blockgaps;
  if (blockgaps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MATNew.tree.blockGaps)
}
inline ::MATNew::blockGapList* tree::release_blockgaps() {
  
  ::MATNew::blockGapList* temp = blockgaps_;
  blockgaps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MATNew::blockGapList* tree::unsafe_arena_release_blockgaps() {
  // @@protoc_insertion_point(field_release:MATNew.tree.blockGaps)
  
  ::MATNew::blockGapList* temp = blockgaps_;
  blockgaps_ = nullptr;
  return temp;
}
inline ::MATNew::blockGapList* tree::_internal_mutable_blockgaps() {
  
  if (blockgaps_ == nullptr) {
    auto* p = CreateMaybeMessage<::MATNew::blockGapList>(GetArenaForAllocation());
    blockgaps_ = p;
  }
  return blockgaps_;
}
inline ::MATNew::blockGapList* tree::mutable_blockgaps() {
  ::MATNew::blockGapList* _msg = _internal_mutable_blockgaps();
  // @@protoc_insertion_point(field_mutable:MATNew.tree.blockGaps)
  return _msg;
}
inline void tree::set_allocated_blockgaps(::MATNew::blockGapList* blockgaps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blockgaps_;
  }
  if (blockgaps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blockgaps);
    if (message_arena != submessage_arena) {
      blockgaps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockgaps, submessage_arena);
    }
    
  } else {
    
  }
  blockgaps_ = blockgaps;
  // @@protoc_insertion_point(field_set_allocated:MATNew.tree.blockGaps)
}

// repeated .MATNew.circularOffset circularSequences = 7;
inline int tree::_internal_circularsequences_size() const {
  return circularsequences_.size();
}
inline int tree::circularsequences_size() const {
  return _internal_circularsequences_size();
}
inline void tree::clear_circularsequences() {
  circularsequences_.Clear();
}
inline ::MATNew::circularOffset* tree::mutable_circularsequences(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.tree.circularSequences)
  return circularsequences_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::circularOffset >*
tree::mutable_circularsequences() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.tree.circularSequences)
  return &circularsequences_;
}
inline const ::MATNew::circularOffset& tree::_internal_circularsequences(int index) const {
  return circularsequences_.Get(index);
}
inline const ::MATNew::circularOffset& tree::circularsequences(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.tree.circularSequences)
  return _internal_circularsequences(index);
}
inline ::MATNew::circularOffset* tree::_internal_add_circularsequences() {
  return circularsequences_.Add();
}
inline ::MATNew::circularOffset* tree::add_circularsequences() {
  ::MATNew::circularOffset* _add = _internal_add_circularsequences();
  // @@protoc_insertion_point(field_add:MATNew.tree.circularSequences)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::circularOffset >&
tree::circularsequences() const {
  // @@protoc_insertion_point(field_list:MATNew.tree.circularSequences)
  return circularsequences_;
}

// -------------------------------------------------------------------

// complexMutation

// bool mutationType = 1;
inline void complexMutation::clear_mutationtype() {
  mutationtype_ = false;
}
inline bool complexMutation::_internal_mutationtype() const {
  return mutationtype_;
}
inline bool complexMutation::mutationtype() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.mutationType)
  return _internal_mutationtype();
}
inline void complexMutation::_internal_set_mutationtype(bool value) {
  
  mutationtype_ = value;
}
inline void complexMutation::set_mutationtype(bool value) {
  _internal_set_mutationtype(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.mutationType)
}

// int32 treeIndex1 = 2;
inline void complexMutation::clear_treeindex1() {
  treeindex1_ = 0;
}
inline int32_t complexMutation::_internal_treeindex1() const {
  return treeindex1_;
}
inline int32_t complexMutation::treeindex1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.treeIndex1)
  return _internal_treeindex1();
}
inline void complexMutation::_internal_set_treeindex1(int32_t value) {
  
  treeindex1_ = value;
}
inline void complexMutation::set_treeindex1(int32_t value) {
  _internal_set_treeindex1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.treeIndex1)
}

// int32 treeIndex2 = 3;
inline void complexMutation::clear_treeindex2() {
  treeindex2_ = 0;
}
inline int32_t complexMutation::_internal_treeindex2() const {
  return treeindex2_;
}
inline int32_t complexMutation::treeindex2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.treeIndex2)
  return _internal_treeindex2();
}
inline void complexMutation::_internal_set_treeindex2(int32_t value) {
  
  treeindex2_ = value;
}
inline void complexMutation::set_treeindex2(int32_t value) {
  _internal_set_treeindex2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.treeIndex2)
}

// int32 treeIndex3 = 4;
inline void complexMutation::clear_treeindex3() {
  treeindex3_ = 0;
}
inline int32_t complexMutation::_internal_treeindex3() const {
  return treeindex3_;
}
inline int32_t complexMutation::treeindex3() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.treeIndex3)
  return _internal_treeindex3();
}
inline void complexMutation::_internal_set_treeindex3(int32_t value) {
  
  treeindex3_ = value;
}
inline void complexMutation::set_treeindex3(int32_t value) {
  _internal_set_treeindex3(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.treeIndex3)
}

// string sequenceId1 = 5;
inline void complexMutation::clear_sequenceid1() {
  sequenceid1_.ClearToEmpty();
}
inline const std::string& complexMutation::sequenceid1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.sequenceId1)
  return _internal_sequenceid1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void complexMutation::set_sequenceid1(ArgT0&& arg0, ArgT... args) {
 
 sequenceid1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.sequenceId1)
}
inline std::string* complexMutation::mutable_sequenceid1() {
  std::string* _s = _internal_mutable_sequenceid1();
  // @@protoc_insertion_point(field_mutable:MATNew.complexMutation.sequenceId1)
  return _s;
}
inline const std::string& complexMutation::_internal_sequenceid1() const {
  return sequenceid1_.Get();
}
inline void complexMutation::_internal_set_sequenceid1(const std::string& value) {
  
  sequenceid1_.Set(value, GetArenaForAllocation());
}
inline std::string* complexMutation::_internal_mutable_sequenceid1() {
  
  return sequenceid1_.Mutable(GetArenaForAllocation());
}
inline std::string* complexMutation::release_sequenceid1() {
  // @@protoc_insertion_point(field_release:MATNew.complexMutation.sequenceId1)
  return sequenceid1_.Release();
}
inline void complexMutation::set_allocated_sequenceid1(std::string* sequenceid1) {
  if (sequenceid1 != nullptr) {
    
  } else {
    
  }
  sequenceid1_.SetAllocated(sequenceid1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sequenceid1_.IsDefault()) {
    sequenceid1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MATNew.complexMutation.sequenceId1)
}

// string sequenceId2 = 6;
inline void complexMutation::clear_sequenceid2() {
  sequenceid2_.ClearToEmpty();
}
inline const std::string& complexMutation::sequenceid2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.sequenceId2)
  return _internal_sequenceid2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void complexMutation::set_sequenceid2(ArgT0&& arg0, ArgT... args) {
 
 sequenceid2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.sequenceId2)
}
inline std::string* complexMutation::mutable_sequenceid2() {
  std::string* _s = _internal_mutable_sequenceid2();
  // @@protoc_insertion_point(field_mutable:MATNew.complexMutation.sequenceId2)
  return _s;
}
inline const std::string& complexMutation::_internal_sequenceid2() const {
  return sequenceid2_.Get();
}
inline void complexMutation::_internal_set_sequenceid2(const std::string& value) {
  
  sequenceid2_.Set(value, GetArenaForAllocation());
}
inline std::string* complexMutation::_internal_mutable_sequenceid2() {
  
  return sequenceid2_.Mutable(GetArenaForAllocation());
}
inline std::string* complexMutation::release_sequenceid2() {
  // @@protoc_insertion_point(field_release:MATNew.complexMutation.sequenceId2)
  return sequenceid2_.Release();
}
inline void complexMutation::set_allocated_sequenceid2(std::string* sequenceid2) {
  if (sequenceid2 != nullptr) {
    
  } else {
    
  }
  sequenceid2_.SetAllocated(sequenceid2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sequenceid2_.IsDefault()) {
    sequenceid2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MATNew.complexMutation.sequenceId2)
}

// int64 blockIdStart1 = 7;
inline void complexMutation::clear_blockidstart1() {
  blockidstart1_ = int64_t{0};
}
inline int64_t complexMutation::_internal_blockidstart1() const {
  return blockidstart1_;
}
inline int64_t complexMutation::blockidstart1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockIdStart1)
  return _internal_blockidstart1();
}
inline void complexMutation::_internal_set_blockidstart1(int64_t value) {
  
  blockidstart1_ = value;
}
inline void complexMutation::set_blockidstart1(int64_t value) {
  _internal_set_blockidstart1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockIdStart1)
}

// bool blockGapExistStart1 = 8;
inline void complexMutation::clear_blockgapexiststart1() {
  blockgapexiststart1_ = false;
}
inline bool complexMutation::_internal_blockgapexiststart1() const {
  return blockgapexiststart1_;
}
inline bool complexMutation::blockgapexiststart1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockGapExistStart1)
  return _internal_blockgapexiststart1();
}
inline void complexMutation::_internal_set_blockgapexiststart1(bool value) {
  
  blockgapexiststart1_ = value;
}
inline void complexMutation::set_blockgapexiststart1(bool value) {
  _internal_set_blockgapexiststart1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockGapExistStart1)
}

// int32 nucPositionStart1 = 9;
inline void complexMutation::clear_nucpositionstart1() {
  nucpositionstart1_ = 0;
}
inline int32_t complexMutation::_internal_nucpositionstart1() const {
  return nucpositionstart1_;
}
inline int32_t complexMutation::nucpositionstart1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucPositionStart1)
  return _internal_nucpositionstart1();
}
inline void complexMutation::_internal_set_nucpositionstart1(int32_t value) {
  
  nucpositionstart1_ = value;
}
inline void complexMutation::set_nucpositionstart1(int32_t value) {
  _internal_set_nucpositionstart1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucPositionStart1)
}

// int32 nucGapPositionStart1 = 10;
inline void complexMutation::clear_nucgappositionstart1() {
  nucgappositionstart1_ = 0;
}
inline int32_t complexMutation::_internal_nucgappositionstart1() const {
  return nucgappositionstart1_;
}
inline int32_t complexMutation::nucgappositionstart1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapPositionStart1)
  return _internal_nucgappositionstart1();
}
inline void complexMutation::_internal_set_nucgappositionstart1(int32_t value) {
  
  nucgappositionstart1_ = value;
}
inline void complexMutation::set_nucgappositionstart1(int32_t value) {
  _internal_set_nucgappositionstart1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapPositionStart1)
}

// bool nucGapExistStart1 = 11;
inline void complexMutation::clear_nucgapexiststart1() {
  nucgapexiststart1_ = false;
}
inline bool complexMutation::_internal_nucgapexiststart1() const {
  return nucgapexiststart1_;
}
inline bool complexMutation::nucgapexiststart1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapExistStart1)
  return _internal_nucgapexiststart1();
}
inline void complexMutation::_internal_set_nucgapexiststart1(bool value) {
  
  nucgapexiststart1_ = value;
}
inline void complexMutation::set_nucgapexiststart1(bool value) {
  _internal_set_nucgapexiststart1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapExistStart1)
}

// int64 blockIdEnd1 = 12;
inline void complexMutation::clear_blockidend1() {
  blockidend1_ = int64_t{0};
}
inline int64_t complexMutation::_internal_blockidend1() const {
  return blockidend1_;
}
inline int64_t complexMutation::blockidend1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockIdEnd1)
  return _internal_blockidend1();
}
inline void complexMutation::_internal_set_blockidend1(int64_t value) {
  
  blockidend1_ = value;
}
inline void complexMutation::set_blockidend1(int64_t value) {
  _internal_set_blockidend1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockIdEnd1)
}

// bool blockGapExistEnd1 = 13;
inline void complexMutation::clear_blockgapexistend1() {
  blockgapexistend1_ = false;
}
inline bool complexMutation::_internal_blockgapexistend1() const {
  return blockgapexistend1_;
}
inline bool complexMutation::blockgapexistend1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockGapExistEnd1)
  return _internal_blockgapexistend1();
}
inline void complexMutation::_internal_set_blockgapexistend1(bool value) {
  
  blockgapexistend1_ = value;
}
inline void complexMutation::set_blockgapexistend1(bool value) {
  _internal_set_blockgapexistend1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockGapExistEnd1)
}

// int32 nucPositionEnd1 = 14;
inline void complexMutation::clear_nucpositionend1() {
  nucpositionend1_ = 0;
}
inline int32_t complexMutation::_internal_nucpositionend1() const {
  return nucpositionend1_;
}
inline int32_t complexMutation::nucpositionend1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucPositionEnd1)
  return _internal_nucpositionend1();
}
inline void complexMutation::_internal_set_nucpositionend1(int32_t value) {
  
  nucpositionend1_ = value;
}
inline void complexMutation::set_nucpositionend1(int32_t value) {
  _internal_set_nucpositionend1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucPositionEnd1)
}

// int32 nucGapPositionEnd1 = 15;
inline void complexMutation::clear_nucgappositionend1() {
  nucgappositionend1_ = 0;
}
inline int32_t complexMutation::_internal_nucgappositionend1() const {
  return nucgappositionend1_;
}
inline int32_t complexMutation::nucgappositionend1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapPositionEnd1)
  return _internal_nucgappositionend1();
}
inline void complexMutation::_internal_set_nucgappositionend1(int32_t value) {
  
  nucgappositionend1_ = value;
}
inline void complexMutation::set_nucgappositionend1(int32_t value) {
  _internal_set_nucgappositionend1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapPositionEnd1)
}

// bool nucGapExistEnd1 = 16;
inline void complexMutation::clear_nucgapexistend1() {
  nucgapexistend1_ = false;
}
inline bool complexMutation::_internal_nucgapexistend1() const {
  return nucgapexistend1_;
}
inline bool complexMutation::nucgapexistend1() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapExistEnd1)
  return _internal_nucgapexistend1();
}
inline void complexMutation::_internal_set_nucgapexistend1(bool value) {
  
  nucgapexistend1_ = value;
}
inline void complexMutation::set_nucgapexistend1(bool value) {
  _internal_set_nucgapexistend1(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapExistEnd1)
}

// int64 blockIdStart2 = 17;
inline void complexMutation::clear_blockidstart2() {
  blockidstart2_ = int64_t{0};
}
inline int64_t complexMutation::_internal_blockidstart2() const {
  return blockidstart2_;
}
inline int64_t complexMutation::blockidstart2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockIdStart2)
  return _internal_blockidstart2();
}
inline void complexMutation::_internal_set_blockidstart2(int64_t value) {
  
  blockidstart2_ = value;
}
inline void complexMutation::set_blockidstart2(int64_t value) {
  _internal_set_blockidstart2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockIdStart2)
}

// bool blockGapExistStart2 = 18;
inline void complexMutation::clear_blockgapexiststart2() {
  blockgapexiststart2_ = false;
}
inline bool complexMutation::_internal_blockgapexiststart2() const {
  return blockgapexiststart2_;
}
inline bool complexMutation::blockgapexiststart2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockGapExistStart2)
  return _internal_blockgapexiststart2();
}
inline void complexMutation::_internal_set_blockgapexiststart2(bool value) {
  
  blockgapexiststart2_ = value;
}
inline void complexMutation::set_blockgapexiststart2(bool value) {
  _internal_set_blockgapexiststart2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockGapExistStart2)
}

// int32 nucPositionStart2 = 19;
inline void complexMutation::clear_nucpositionstart2() {
  nucpositionstart2_ = 0;
}
inline int32_t complexMutation::_internal_nucpositionstart2() const {
  return nucpositionstart2_;
}
inline int32_t complexMutation::nucpositionstart2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucPositionStart2)
  return _internal_nucpositionstart2();
}
inline void complexMutation::_internal_set_nucpositionstart2(int32_t value) {
  
  nucpositionstart2_ = value;
}
inline void complexMutation::set_nucpositionstart2(int32_t value) {
  _internal_set_nucpositionstart2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucPositionStart2)
}

// int32 nucGapPositionStart2 = 20;
inline void complexMutation::clear_nucgappositionstart2() {
  nucgappositionstart2_ = 0;
}
inline int32_t complexMutation::_internal_nucgappositionstart2() const {
  return nucgappositionstart2_;
}
inline int32_t complexMutation::nucgappositionstart2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapPositionStart2)
  return _internal_nucgappositionstart2();
}
inline void complexMutation::_internal_set_nucgappositionstart2(int32_t value) {
  
  nucgappositionstart2_ = value;
}
inline void complexMutation::set_nucgappositionstart2(int32_t value) {
  _internal_set_nucgappositionstart2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapPositionStart2)
}

// bool nucGapExistStart2 = 21;
inline void complexMutation::clear_nucgapexiststart2() {
  nucgapexiststart2_ = false;
}
inline bool complexMutation::_internal_nucgapexiststart2() const {
  return nucgapexiststart2_;
}
inline bool complexMutation::nucgapexiststart2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapExistStart2)
  return _internal_nucgapexiststart2();
}
inline void complexMutation::_internal_set_nucgapexiststart2(bool value) {
  
  nucgapexiststart2_ = value;
}
inline void complexMutation::set_nucgapexiststart2(bool value) {
  _internal_set_nucgapexiststart2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapExistStart2)
}

// int64 blockIdEnd2 = 22;
inline void complexMutation::clear_blockidend2() {
  blockidend2_ = int64_t{0};
}
inline int64_t complexMutation::_internal_blockidend2() const {
  return blockidend2_;
}
inline int64_t complexMutation::blockidend2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockIdEnd2)
  return _internal_blockidend2();
}
inline void complexMutation::_internal_set_blockidend2(int64_t value) {
  
  blockidend2_ = value;
}
inline void complexMutation::set_blockidend2(int64_t value) {
  _internal_set_blockidend2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockIdEnd2)
}

// bool blockGapExistEnd2 = 23;
inline void complexMutation::clear_blockgapexistend2() {
  blockgapexistend2_ = false;
}
inline bool complexMutation::_internal_blockgapexistend2() const {
  return blockgapexistend2_;
}
inline bool complexMutation::blockgapexistend2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.blockGapExistEnd2)
  return _internal_blockgapexistend2();
}
inline void complexMutation::_internal_set_blockgapexistend2(bool value) {
  
  blockgapexistend2_ = value;
}
inline void complexMutation::set_blockgapexistend2(bool value) {
  _internal_set_blockgapexistend2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.blockGapExistEnd2)
}

// int32 nucPositionEnd2 = 24;
inline void complexMutation::clear_nucpositionend2() {
  nucpositionend2_ = 0;
}
inline int32_t complexMutation::_internal_nucpositionend2() const {
  return nucpositionend2_;
}
inline int32_t complexMutation::nucpositionend2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucPositionEnd2)
  return _internal_nucpositionend2();
}
inline void complexMutation::_internal_set_nucpositionend2(int32_t value) {
  
  nucpositionend2_ = value;
}
inline void complexMutation::set_nucpositionend2(int32_t value) {
  _internal_set_nucpositionend2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucPositionEnd2)
}

// int32 nucGapPositionEnd2 = 25;
inline void complexMutation::clear_nucgappositionend2() {
  nucgappositionend2_ = 0;
}
inline int32_t complexMutation::_internal_nucgappositionend2() const {
  return nucgappositionend2_;
}
inline int32_t complexMutation::nucgappositionend2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapPositionEnd2)
  return _internal_nucgappositionend2();
}
inline void complexMutation::_internal_set_nucgappositionend2(int32_t value) {
  
  nucgappositionend2_ = value;
}
inline void complexMutation::set_nucgappositionend2(int32_t value) {
  _internal_set_nucgappositionend2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapPositionEnd2)
}

// bool nucGapExistEnd2 = 26;
inline void complexMutation::clear_nucgapexistend2() {
  nucgapexistend2_ = false;
}
inline bool complexMutation::_internal_nucgapexistend2() const {
  return nucgapexistend2_;
}
inline bool complexMutation::nucgapexistend2() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.nucGapExistEnd2)
  return _internal_nucgapexistend2();
}
inline void complexMutation::_internal_set_nucgapexistend2(bool value) {
  
  nucgapexistend2_ = value;
}
inline void complexMutation::set_nucgapexistend2(bool value) {
  _internal_set_nucgapexistend2(value);
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.nucGapExistEnd2)
}

// string sequenceId3 = 27;
inline void complexMutation::clear_sequenceid3() {
  sequenceid3_.ClearToEmpty();
}
inline const std::string& complexMutation::sequenceid3() const {
  // @@protoc_insertion_point(field_get:MATNew.complexMutation.sequenceId3)
  return _internal_sequenceid3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void complexMutation::set_sequenceid3(ArgT0&& arg0, ArgT... args) {
 
 sequenceid3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MATNew.complexMutation.sequenceId3)
}
inline std::string* complexMutation::mutable_sequenceid3() {
  std::string* _s = _internal_mutable_sequenceid3();
  // @@protoc_insertion_point(field_mutable:MATNew.complexMutation.sequenceId3)
  return _s;
}
inline const std::string& complexMutation::_internal_sequenceid3() const {
  return sequenceid3_.Get();
}
inline void complexMutation::_internal_set_sequenceid3(const std::string& value) {
  
  sequenceid3_.Set(value, GetArenaForAllocation());
}
inline std::string* complexMutation::_internal_mutable_sequenceid3() {
  
  return sequenceid3_.Mutable(GetArenaForAllocation());
}
inline std::string* complexMutation::release_sequenceid3() {
  // @@protoc_insertion_point(field_release:MATNew.complexMutation.sequenceId3)
  return sequenceid3_.Release();
}
inline void complexMutation::set_allocated_sequenceid3(std::string* sequenceid3) {
  if (sequenceid3 != nullptr) {
    
  } else {
    
  }
  sequenceid3_.SetAllocated(sequenceid3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sequenceid3_.IsDefault()) {
    sequenceid3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MATNew.complexMutation.sequenceId3)
}

// -------------------------------------------------------------------

// treeGroup

// repeated .MATNew.tree trees = 1;
inline int treeGroup::_internal_trees_size() const {
  return trees_.size();
}
inline int treeGroup::trees_size() const {
  return _internal_trees_size();
}
inline void treeGroup::clear_trees() {
  trees_.Clear();
}
inline ::MATNew::tree* treeGroup::mutable_trees(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.treeGroup.trees)
  return trees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::tree >*
treeGroup::mutable_trees() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.treeGroup.trees)
  return &trees_;
}
inline const ::MATNew::tree& treeGroup::_internal_trees(int index) const {
  return trees_.Get(index);
}
inline const ::MATNew::tree& treeGroup::trees(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.treeGroup.trees)
  return _internal_trees(index);
}
inline ::MATNew::tree* treeGroup::_internal_add_trees() {
  return trees_.Add();
}
inline ::MATNew::tree* treeGroup::add_trees() {
  ::MATNew::tree* _add = _internal_add_trees();
  // @@protoc_insertion_point(field_add:MATNew.treeGroup.trees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::tree >&
treeGroup::trees() const {
  // @@protoc_insertion_point(field_list:MATNew.treeGroup.trees)
  return trees_;
}

// repeated .MATNew.complexMutation complexMutations = 2;
inline int treeGroup::_internal_complexmutations_size() const {
  return complexmutations_.size();
}
inline int treeGroup::complexmutations_size() const {
  return _internal_complexmutations_size();
}
inline void treeGroup::clear_complexmutations() {
  complexmutations_.Clear();
}
inline ::MATNew::complexMutation* treeGroup::mutable_complexmutations(int index) {
  // @@protoc_insertion_point(field_mutable:MATNew.treeGroup.complexMutations)
  return complexmutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::complexMutation >*
treeGroup::mutable_complexmutations() {
  // @@protoc_insertion_point(field_mutable_list:MATNew.treeGroup.complexMutations)
  return &complexmutations_;
}
inline const ::MATNew::complexMutation& treeGroup::_internal_complexmutations(int index) const {
  return complexmutations_.Get(index);
}
inline const ::MATNew::complexMutation& treeGroup::complexmutations(int index) const {
  // @@protoc_insertion_point(field_get:MATNew.treeGroup.complexMutations)
  return _internal_complexmutations(index);
}
inline ::MATNew::complexMutation* treeGroup::_internal_add_complexmutations() {
  return complexmutations_.Add();
}
inline ::MATNew::complexMutation* treeGroup::add_complexmutations() {
  ::MATNew::complexMutation* _add = _internal_add_complexmutations();
  // @@protoc_insertion_point(field_add:MATNew.treeGroup.complexMutations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MATNew::complexMutation >&
treeGroup::complexmutations() const {
  // @@protoc_insertion_point(field_list:MATNew.treeGroup.complexMutations)
  return complexmutations_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MATNew

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mutation_5fannotation_5ftest_5fproto3_5foptional_5fnew_2eproto
